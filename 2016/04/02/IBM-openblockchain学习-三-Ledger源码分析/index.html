
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>IBM openblockchain学习(三)--Ledger源码分析 | XingLiu&#39;s  Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="XingLiu">
    

    
    <meta name="description" content="Ledger是总账簿的意思，也就是blockchain中存储交易记录的部分。其代码包含如下，这块代码量大，可能分析时间会很长，希望读者耐心等待。">
<meta property="og:type" content="article">
<meta property="og:title" content="IBM openblockchain学习(三)--Ledger源码分析">
<meta property="og:url" content="http://pangjiuzala.github.io/2016/04/02/IBM-openblockchain学习-三-Ledger源码分析/index.html">
<meta property="og:site_name" content="XingLiu's  Blog">
<meta property="og:description" content="Ledger是总账簿的意思，也就是blockchain中存储交易记录的部分。其代码包含如下，这块代码量大，可能分析时间会很长，希望读者耐心等待。">
<meta property="og:updated_time" content="2016-04-04T11:40:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IBM openblockchain学习(三)--Ledger源码分析">
<meta name="twitter:description" content="Ledger是总账簿的意思，也就是blockchain中存储交易记录的部分。其代码包含如下，这块代码量大，可能分析时间会很长，希望读者耐心等待。">

    
    <link rel="alternative" href="https://github.com/search?q=pangjiuzala&type=Users" title="XingLiu&#39;s  Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="XingLiu&#39;s  Blog" title="XingLiu&#39;s  Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="XingLiu&#39;s  Blog">XingLiu&#39;s  Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">文章列表</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/02/IBM-openblockchain学习-三-Ledger源码分析/" title="IBM openblockchain学习(三)--Ledger源码分析" itemprop="url">IBM openblockchain学习(三)--Ledger源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="XingLiu" target="_blank" itemprop="author">XingLiu</a>
		
  <p class="article-time">
    <time datetime="2016-04-02T07:48:39.000Z" itemprop="datePublished"> 发表于 2016-04-02</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain"><span class="toc-number">1.</span> <span class="toc-text">blockchain</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newBlockchain"><span class="toc-number">1.1.</span> <span class="toc-text">newBlockchain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#startIndexer()"><span class="toc-number">1.2.</span> <span class="toc-text">startIndexer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getLastBlock"><span class="toc-number">1.3.</span> <span class="toc-text">getLastBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getSize"><span class="toc-number">1.4.</span> <span class="toc-text">getSize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlock"><span class="toc-number">1.5.</span> <span class="toc-text">getBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlockByHash"><span class="toc-number">1.6.</span> <span class="toc-text">getBlockByHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionByUUID"><span class="toc-number">1.7.</span> <span class="toc-text">getTransactionByUUID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactions"><span class="toc-number">1.8.</span> <span class="toc-text">getTransactions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionsByBlockHash"><span class="toc-number">1.9.</span> <span class="toc-text">getTransactionsByBlockHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransaction"><span class="toc-number">1.10.</span> <span class="toc-text">getTransaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionByBlockHash"><span class="toc-number">1.11.</span> <span class="toc-text">getTransactionByBlockHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlockchainInfo"><span class="toc-number">1.12.</span> <span class="toc-text">getBlockchainInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buildBlock"><span class="toc-number">1.13.</span> <span class="toc-text">buildBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addPersistenceChangesForNewBlock"><span class="toc-number">1.14.</span> <span class="toc-text">addPersistenceChangesForNewBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blockPersistenceStatus"><span class="toc-number">1.15.</span> <span class="toc-text">blockPersistenceStatus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#persistRawBlock"><span class="toc-number">1.16.</span> <span class="toc-text">persistRawBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockFromDB"><span class="toc-number">1.17.</span> <span class="toc-text">fetchBlockFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchTransactionFromDB"><span class="toc-number">1.18.</span> <span class="toc-text">fetchTransactionFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockchainSizeFromDB"><span class="toc-number">1.19.</span> <span class="toc-text">fetchBlockchainSizeFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockchainSizeFromSnapshot"><span class="toc-number">1.20.</span> <span class="toc-text">fetchBlockchainSizeFromSnapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.21.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain_indexes"><span class="toc-number">2.</span> <span class="toc-text">blockchain_indexes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#addIndexDataForPersistence"><span class="toc-number">2.1.</span> <span class="toc-text">addIndexDataForPersistence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getAuthorisedAddresses"><span class="toc-number">2.2.</span> <span class="toc-text">getAuthorisedAddresses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodeBlockNumber"><span class="toc-number">2.3.</span> <span class="toc-text">encodeBlockNumber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodeBlockNumTxIndex"><span class="toc-number">2.4.</span> <span class="toc-text">encodeBlockNumTxIndex</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain_indexes_async"><span class="toc-number">3.</span> <span class="toc-text">blockchain_indexes_async</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#createIndexesInternal"><span class="toc-number">3.1.</span> <span class="toc-text">createIndexesInternal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#indexPendingBlocks"><span class="toc-number">3.2.</span> <span class="toc-text">indexPendingBlocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blockIndexed"><span class="toc-number">3.3.</span> <span class="toc-text">blockIndexed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitForLastCommittedBlock"><span class="toc-number">3.4.</span> <span class="toc-text">waitForLastCommittedBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchLastIndexedBlockNumFromDB"><span class="toc-number">3.5.</span> <span class="toc-text">fetchLastIndexedBlockNumFromDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ledger"><span class="toc-number">4.</span> <span class="toc-text">ledger</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GetLedger"><span class="toc-number">4.1.</span> <span class="toc-text">GetLedger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeginTxBatch"><span class="toc-number">4.2.</span> <span class="toc-text">BeginTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTXBatchPreviewBlock"><span class="toc-number">4.3.</span> <span class="toc-text">GetTXBatchPreviewBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitTxBatch"><span class="toc-number">4.4.</span> <span class="toc-text">CommitTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RollbackTxBatch"><span class="toc-number">4.5.</span> <span class="toc-text">RollbackTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TxBegin"><span class="toc-number">4.6.</span> <span class="toc-text">TxBegin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TxFinished"><span class="toc-number">4.7.</span> <span class="toc-text">TxFinished</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTempStateHash"><span class="toc-number">4.8.</span> <span class="toc-text">GetTempStateHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTempStateHashWithTxDeltaStateHashes"><span class="toc-number">4.9.</span> <span class="toc-text">GetTempStateHashWithTxDeltaStateHashes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetState"><span class="toc-number">4.10.</span> <span class="toc-text">GetState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateRangeScanIterator"><span class="toc-number">4.11.</span> <span class="toc-text">GetStateRangeScanIterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateSnapshot"><span class="toc-number">4.12.</span> <span class="toc-text">GetStateSnapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateDelta"><span class="toc-number">4.13.</span> <span class="toc-text">GetStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyStateDelta"><span class="toc-number">4.14.</span> <span class="toc-text">ApplyStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitStateDelta"><span class="toc-number">4.15.</span> <span class="toc-text">CommitStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RollbackStateDelta"><span class="toc-number">4.16.</span> <span class="toc-text">RollbackStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VerifyChain"><span class="toc-number">4.17.</span> <span class="toc-text">VerifyChain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sendProducerBlockEvent"><span class="toc-number">4.18.</span> <span class="toc-text">sendProducerBlockEvent</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#genesis"><span class="toc-number">5.</span> <span class="toc-text">genesis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MakeGenesis"><span class="toc-number">5.1.</span> <span class="toc-text">MakeGenesis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BuildLocal"><span class="toc-number">5.2.</span> <span class="toc-text">BuildLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DeployLocal"><span class="toc-number">5.3.</span> <span class="toc-text">DeployLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deployUpdateValidityPeriodChaincode"><span class="toc-number">5.4.</span> <span class="toc-text">deployUpdateValidityPeriodChaincode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#util"><span class="toc-number">6.</span> <span class="toc-text">util</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EncodeOrderPreservingVarUint64"><span class="toc-number">6.1.</span> <span class="toc-text">EncodeOrderPreservingVarUint64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DecodeOrderPreservingVarUint64"><span class="toc-number">6.2.</span> <span class="toc-text">DecodeOrderPreservingVarUint64</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buckettree"><span class="toc-number">7.</span> <span class="toc-text">buckettree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_hash"><span class="toc-number">7.1.</span> <span class="toc-text">bucket_hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addNextNode"><span class="toc-number">7.1.1.</span> <span class="toc-text">addNextNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeCryptoHash"><span class="toc-number">7.1.2.</span> <span class="toc-text">computeCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendCurrentChaincodeData"><span class="toc-number">7.1.3.</span> <span class="toc-text">appendCurrentChaincodeData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendSizeAndData"><span class="toc-number">7.1.4.</span> <span class="toc-text">appendSizeAndData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendSize"><span class="toc-number">7.1.5.</span> <span class="toc-text">appendSize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_key"><span class="toc-number">7.2.</span> <span class="toc-text">bucket_key</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newBucketKey"><span class="toc-number">7.2.1.</span> <span class="toc-text">newBucketKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getChildIndex"><span class="toc-number">7.2.2.</span> <span class="toc-text">getChildIndex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_node"><span class="toc-number">7.3.</span> <span class="toc-text">bucket_node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unmarshalBucketNode"><span class="toc-number">7.3.1.</span> <span class="toc-text">unmarshalBucketNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mergeBucketNode"><span class="toc-number">7.3.2.</span> <span class="toc-text">mergeBucketNode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_tree_delta"><span class="toc-number">7.4.</span> <span class="toc-text">bucket_tree_delta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#config"><span class="toc-number">7.5.</span> <span class="toc-text">config</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datakey"><span class="toc-number">7.6.</span> <span class="toc-text">Datakey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data_nodes_delta"><span class="toc-number">7.7.</span> <span class="toc-text">data_nodes_delta</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newDataNodesDelta"><span class="toc-number">7.7.1.</span> <span class="toc-text">newDataNodesDelta</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getAffectedBuckets"><span class="toc-number">7.7.2.</span> <span class="toc-text">getAffectedBuckets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range_scan_iterator"><span class="toc-number">7.8.</span> <span class="toc-text">range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snapshot_iterator"><span class="toc-number">7.9.</span> <span class="toc-text">snapshot_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_impl"><span class="toc-number">7.10.</span> <span class="toc-text">state_impl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewStateImpl"><span class="toc-number">7.10.1.</span> <span class="toc-text">NewStateImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialize"><span class="toc-number">7.10.2.</span> <span class="toc-text">Initialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrepareWorkingSet"><span class="toc-number">7.10.3.</span> <span class="toc-text">PrepareWorkingSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeDataNodesCryptoHash"><span class="toc-number">7.10.4.</span> <span class="toc-text">computeDataNodesCryptoHash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state"><span class="toc-number">8.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#composite_range_scan_iterator"><span class="toc-number">8.1.</span> <span class="toc-text">composite_range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_snapshot"><span class="toc-number">8.2.</span> <span class="toc-text">state_snapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state-1"><span class="toc-number">8.3.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewState"><span class="toc-number">8.3.1.</span> <span class="toc-text">NewState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TxBegin-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">TxBegin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get"><span class="toc-number">8.3.3.</span> <span class="toc-text">Get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetRangeScanIterator"><span class="toc-number">8.3.4.</span> <span class="toc-text">GetRangeScanIterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetHash"><span class="toc-number">8.3.5.</span> <span class="toc-text">GetHash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#trie"><span class="toc-number">9.</span> <span class="toc-text">trie</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TrieKey"><span class="toc-number">9.1.</span> <span class="toc-text">TrieKey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieKey"><span class="toc-number">9.1.1.</span> <span class="toc-text">newTrieKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieKeyFromCompositeKey"><span class="toc-number">9.1.2.</span> <span class="toc-text">newTrieKeyFromCompositeKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getIndexInParent"><span class="toc-number">9.1.3.</span> <span class="toc-text">getIndexInParent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getParentTrieKey"><span class="toc-number">9.1.4.</span> <span class="toc-text">getParentTrieKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getEncodedBytes"><span class="toc-number">9.1.5.</span> <span class="toc-text">getEncodedBytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assertIsChildOf"><span class="toc-number">9.1.6.</span> <span class="toc-text">assertIsChildOf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trie_node"><span class="toc-number">9.2.</span> <span class="toc-text">trie_node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setChildCryptoHash"><span class="toc-number">9.2.1.</span> <span class="toc-text">setChildCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mergeMissingAttributesFrom"><span class="toc-number">9.2.2.</span> <span class="toc-text">mergeMissingAttributesFrom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeCryptoHash-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">computeCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#marshal"><span class="toc-number">9.2.4.</span> <span class="toc-text">marshal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSortedChildrenIndex"><span class="toc-number">9.2.5.</span> <span class="toc-text">getSortedChildrenIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieDelta"><span class="toc-number">9.2.6.</span> <span class="toc-text">newTrieDelta</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trie_db_helper"><span class="toc-number">9.3.</span> <span class="toc-text">trie_db_helper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#byteTrieKey"><span class="toc-number">9.4.</span> <span class="toc-text">byteTrieKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hexTrieKey"><span class="toc-number">9.5.</span> <span class="toc-text">hexTrieKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range_scan_iterator-1"><span class="toc-number">9.6.</span> <span class="toc-text">range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snapshot_iterator-1"><span class="toc-number">9.7.</span> <span class="toc-text">snapshot_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_trie"><span class="toc-number">9.8.</span> <span class="toc-text">state_trie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#processChangedNode"><span class="toc-number">9.8.1.</span> <span class="toc-text">processChangedNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AddChangesForPersistence"><span class="toc-number">9.8.2.</span> <span class="toc-text">AddChangesForPersistence</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commons"><span class="toc-number">10.</span> <span class="toc-text">commons</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashable_state"><span class="toc-number">10.1.</span> <span class="toc-text">hashable_state</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state_delta_iterator"><span class="toc-number">11.</span> <span class="toc-text">state_delta_iterator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state_delta"><span class="toc-number">12.</span> <span class="toc-text">state_delta</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IsUpdatedValueSet"><span class="toc-number">12.1.</span> <span class="toc-text">IsUpdatedValueSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyChanges"><span class="toc-number">12.2.</span> <span class="toc-text">ApplyChanges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetUpdatedChaincodeIds"><span class="toc-number">12.3.</span> <span class="toc-text">GetUpdatedChaincodeIds</span></a></li></ol></li></ol>
		
		</div>
		
		<p> Ledger是总账簿的意思，也就是blockchain中存储交易记录的部分。其代码包含如下，这块代码量大，可能分析时间会很长，希望读者耐心等待。<br> <a id="more"></a></p>
<h1 id="blockchain">blockchain</h1><p>先看下Blockchain在内存中保存的基本信息，Blockchain中的操作不是线程安全的<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">	size               <span class="typename">uint64</span>  <span class="comment">//块大小</span></span><br><span class="line">	previousBlockHash  []<span class="typename">byte</span>   <span class="comment">//上一个块的哈希</span></span><br><span class="line">	indexer            blockchainIndexer <span class="comment">//块索引</span></span><br><span class="line">	lastProcessedBlock *lastProcessedBlock  <span class="comment">//最后处理的块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后处理的块的结构<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">type</span> lastProcessedBlock <span class="keyword">struct </span>&#123;</span><br><span class="line">	<span class="keyword">block </span>      *protos.<span class="keyword">Block</span><br><span class="line"></span>	<span class="keyword">blockNumber </span>uint64  块数</span><br><span class="line">	<span class="keyword">blockHash </span>  []<span class="keyword">byte </span>块哈希值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="newBlockchain">newBlockchain</h2><p>newBlockchain()用于创建一个区块<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">newBlockchain</span><span class="params">()</span></span> (*blockchain, error) &#123;</span><br><span class="line">	size, err := fetchBlockchainSizeFromDB()<span class="comment">//从数据库中读取blockchain的大小</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	blockchain := &amp;blockchain&#123;<span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	blockchain.size = size</span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">		previousBlock, err := fetchBlockFromDB(size - <span class="number">1</span>)</span><br><span class="line">		<span class="comment">//如果为创世区块，则上一个块是创世区块的大小减一</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		previousBlockHash, err := previousBlock.<span class="type">GetHash</span>()</span><br><span class="line">		<span class="comment">//获取前驱块的哈希</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		blockchain.previousBlockHash = previousBlockHash</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = blockchain.startIndexer()</span><br><span class="line">	<span class="comment">//开始创建索引</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blockchain, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="startIndexer()">startIndexer()</h2><p>创建索引<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span> <span class="title">startIndexer</span><span class="params">()</span> <span class="params">(err error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">if</span> indexBlockDataSynchronously &#123;</span><br><span class="line">		blockchain.indexer = newBlockchainIndexerSync()</span><br><span class="line">		//同步创建区块链索引</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		blockchain.indexer = newBlockchainIndexerAsync()</span><br><span class="line">	&#125;</span><br><span class="line">	err = blockchain.indexer.start(blockchain)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getLastBlock">getLastBlock</h2><p>getLastBlock创建最后区块</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span> <span class="title">getLastBlock</span><span class="params">()</span> <span class="params">(*protos.Block, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">if</span> blockchain.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, nil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blockchain.getBlock(blockchain.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getSize">getSize</h2><p>getSize用于返回块大小</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span> <span class="title">getSize</span><span class="params">()</span> <span class="title">uint64</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> blockchain.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getBlock">getBlock</h2><p>在blockchain中通过任意高度获取块<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span> <span class="title">getBlock</span><span class="params">(blockNumber uint64)</span> <span class="params">(*protos.Block, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> fetchBlockFromDB(blockNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getBlockByHash">getBlockByHash</h2><p>通过块的哈希获取块</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">blockchain </span>*<span class="keyword">blockchain) </span>getBlockByHash(<span class="keyword">blockHash </span>[]<span class="keyword">byte) </span>(*protos.<span class="keyword">Block, </span>error) &#123;</span><br><span class="line">	<span class="keyword">blockNumber, </span>err := <span class="keyword">blockchain.indexer.fetchBlockNumberByBlockHash(blockHash)</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">blockchain.getBlock(blockNumber)</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getTransactionByUUID">getTransactionByUUID</h2><p>通过UUID获取交易记录<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">func (blockchain *blockchain) getTransactionByU<span class="built_in">UID</span>(txU<span class="built_in">UID</span> string) (*protos<span class="variable">.Transaction</span>, error) &#123;</span><br><span class="line">	blockNumber, txIndex, err := blockchain<span class="variable">.indexer</span><span class="variable">.fetchTransactionIndexByUUID</span>(txU<span class="built_in">UID</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := blockchain<span class="variable">.getBlock</span>(blockNumber)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	transaction := block<span class="variable">.GetTransactions</span>()[txIndex]</span><br><span class="line">	<span class="keyword">return</span> transaction, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getTransactions">getTransactions</h2><p>通过有块号标识的块获取所有的交易<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span></span> getTransactions(blockNumber uint64) ([]*protos.<span class="type">Transaction</span>, error) &#123;</span><br><span class="line">	block, err := blockchain.getBlock(blockNumber)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block.<span class="type">GetTransactions</span>(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getTransactionsByBlockHash">getTransactionsByBlockHash</h2><p>通过块的哈希获取所有的交易<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(blockchain *blockchain)</span></span> getTransactionsByBlockHash(blockHash []byte) ([]*protos.<span class="type">Transaction</span>, error) &#123;</span><br><span class="line">	block, err := blockchain.getBlockByHash(blockHash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block.<span class="type">GetTransactions</span>(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getTransaction">getTransaction</h2><p>通过数块和确定块内索引获取交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (blockchain *blockchain) getTransaction(blockNumber <span class="typename">uint64</span>, txIndex <span class="typename">uint64</span>) (*protos.Transaction, error) &#123;</span><br><span class="line">	block, err := blockchain.getBlock(blockNumber)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block.GetTransactions()[txIndex], <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getTransactionByBlockHash">getTransactionByBlockHash</h2><p>通过块内块的哈希和标识索引获取交易<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (blockchain *blockchain) getTransactionByBlockHash(blockHash []<span class="typename">byte</span>, txIndex <span class="typename">uint64</span>) (*protos.Transaction, error) &#123;</span><br><span class="line">	block, err := blockchain.getBlockByHash(blockHash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block.GetTransactions()[txIndex], <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getBlockchainInfo">getBlockchainInfo</h2><p>获取区块链的信息</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">blockchain </span>*<span class="keyword">blockchain) </span>getBlockchainInfo() (*protos.<span class="keyword">BlockchainInfo, </span>error) &#123;</span><br><span class="line">	<span class="preprocessor">if</span> <span class="keyword">blockchain.getSize() </span>== <span class="number">0</span> &#123;</span><br><span class="line">		return &amp;protos.<span class="keyword">BlockchainInfo&#123;Height: </span><span class="number">0</span>&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastBlock, err := <span class="keyword">blockchain.getLastBlock()</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">info</span> := &amp;protos.<span class="keyword">BlockchainInfo&#123;</span><br><span class="line"></span><span class="label">		Height:</span>            <span class="keyword">blockchain.getSize(),</span><br><span class="line"></span><span class="label">		CurrentBlockHash:</span>  <span class="keyword">blockchain.previousBlockHash,</span><br><span class="line"></span><span class="label">		PreviousBlockHash:</span> lastBlock.PreviousBlockHash&#125;</span><br><span class="line"></span><br><span class="line">	return <span class="preprocessor">info</span>, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="buildBlock">buildBlock</h2><p>创建块</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (blockchain *blockchain) buildBlock(<span class="built_in">block</span> *protos.Block, <span class="keyword">state</span>Hash []byte) *protos.Block &#123;</span><br><span class="line">	<span class="built_in">block</span>.SetPreviousBlockHash(blockchain.previousBlockHash)</span><br><span class="line">	<span class="built_in">block</span>.StateHash = <span class="keyword">state</span>Hash</span><br><span class="line">	return <span class="built_in">block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="addPersistenceChangesForNewBlock">addPersistenceChangesForNewBlock</h2><p>对于新块添加持久性的更改<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">blockchain </span>*<span class="keyword">blockchain) </span><span class="keyword">addPersistenceChangesForNewBlock(ctx </span>context.Context,</span><br><span class="line">	<span class="keyword">block </span>*protos.<span class="keyword">Block, </span>stateHash []<span class="keyword">byte, </span>writeBatch *gorocksdb.WriteBatch) (uint64, error) &#123;</span><br><span class="line">	<span class="keyword">block </span>= <span class="keyword">blockchain.buildBlock(block, </span>stateHash)</span><br><span class="line">	<span class="preprocessor">if</span> <span class="keyword">block.NonHashData </span>== nil &#123;</span><br><span class="line">		<span class="keyword">block.NonHashData </span>= &amp;protos.NonHashData&#123;LocalLedgerCommitTimestamp: util.CreateUtcTimestamp()&#125;</span><br><span class="line">	&#125; <span class="preprocessor">else</span> &#123;</span><br><span class="line">		<span class="keyword">block.NonHashData.LocalLedgerCommitTimestamp </span>= util.CreateUtcTimestamp()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">blockNumber </span>:= <span class="keyword">blockchain.size</span><br><span class="line"></span>	<span class="keyword">blockHash, </span>err := <span class="keyword">block.GetHash()</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">blockBytes, </span><span class="keyword">blockBytesErr </span>:= <span class="keyword">block.Bytes()</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">blockBytesErr </span>!= nil &#123;</span><br><span class="line">		return <span class="number">0</span>, <span class="keyword">blockBytesErr</span><br><span class="line"></span>	&#125;</span><br><span class="line">	writeBatch.PutCF(db.GetDBHandle().<span class="keyword">BlockchainCF, </span>encodeBlockNumberDBKey(<span class="keyword">blockNumber), </span><span class="keyword">blockBytes)</span><br><span class="line"></span>	writeBatch.PutCF(db.GetDBHandle().<span class="keyword">BlockchainCF, </span><span class="keyword">blockCountKey, </span>encodeUint64(<span class="keyword">blockNumber+1))</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">blockchain.indexer.isSynchronous() </span>&#123;</span><br><span class="line">		<span class="keyword">blockchain.indexer.createIndexesSync(block, </span><span class="keyword">blockNumber, </span><span class="keyword">blockHash, </span>writeBatch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">blockchain.lastProcessedBlock </span>= &amp;lastProcessedBlock&#123;<span class="keyword">block, </span><span class="keyword">blockNumber, </span><span class="keyword">blockHash&#125;</span><br><span class="line"></span>	return <span class="keyword">blockNumber, </span>nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="blockPersistenceStatus">blockPersistenceStatus</h2><p>块持久状态</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">blockchain </span>*<span class="keyword">blockchain) </span><span class="keyword">blockPersistenceStatus(success </span><span class="keyword">bool) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> success &#123;</span><br><span class="line">		<span class="keyword">blockchain.size++</span><br><span class="line"></span>		<span class="keyword">blockchain.previousBlockHash </span>= <span class="keyword">blockchain.lastProcessedBlock.blockHash</span><br><span class="line"></span>		<span class="preprocessor">if</span> !<span class="keyword">blockchain.indexer.isSynchronous() </span>&#123;</span><br><span class="line">			<span class="keyword">blockchain.indexer.createIndexesAsync(blockchain.lastProcessedBlock.block,</span><br><span class="line"></span>				<span class="keyword">blockchain.lastProcessedBlock.blockNumber, </span><span class="keyword">blockchain.lastProcessedBlock.blockHash)</span><br><span class="line"></span>		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">blockchain.lastProcessedBlock </span>= nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="persistRawBlock">persistRawBlock</h2><p>持久化原始块</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">blockchain </span>*<span class="keyword">blockchain) </span>persistRawBlock(<span class="keyword">block </span>*protos.<span class="keyword">Block, </span><span class="keyword">blockNumber </span>uint64) error &#123;</span><br><span class="line">	<span class="keyword">blockBytes, </span><span class="keyword">blockBytesErr </span>:= <span class="keyword">block.Bytes()</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">blockBytesErr </span>!= nil &#123;</span><br><span class="line">		return <span class="keyword">blockBytesErr</span><br><span class="line"></span>	&#125;</span><br><span class="line">	writeBatch := gorocksdb.NewWriteBatch()</span><br><span class="line">	defer writeBatch.Destroy()</span><br><span class="line">	writeBatch.PutCF(db.GetDBHandle().<span class="keyword">BlockchainCF, </span>encodeBlockNumberDBKey(<span class="keyword">blockNumber), </span><span class="keyword">blockBytes)</span><br><span class="line"></span></span><br><span class="line">	// 它需要检查，因为我们在这样的情况下块/状态同步支持乱序块。其真正意义区块链的高度，而不是规模。</span><br><span class="line">	<span class="preprocessor">if</span> <span class="keyword">blockchain.getSize() </span>&lt; <span class="keyword">blockNumber+1 </span>&#123;</span><br><span class="line">		sizeBytes := encodeUint64(<span class="keyword">blockNumber </span>+ <span class="number">1</span>)</span><br><span class="line">		writeBatch.PutCF(db.GetDBHandle().<span class="keyword">BlockchainCF, </span><span class="keyword">blockCountKey, </span>sizeBytes)</span><br><span class="line">		<span class="keyword">blockchain.size </span>= <span class="keyword">blockNumber </span>+ <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">blockHash, </span>err := <span class="keyword">block.GetHash()</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">if</span> <span class="keyword">blockchain.indexer.isSynchronous() </span>&#123;</span><br><span class="line">		<span class="keyword">blockchain.indexer.createIndexesSync(block, </span><span class="keyword">blockNumber, </span><span class="keyword">blockHash, </span>writeBatch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">opt</span> := gorocksdb.NewDefaultWriteOptions()</span><br><span class="line">	defer <span class="preprocessor">opt</span>.Destroy()</span><br><span class="line">	err = db.GetDBHandle().DB.Write(<span class="preprocessor">opt</span>, writeBatch)</span><br><span class="line">	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fetchBlockFromDB">fetchBlockFromDB</h2><p>从数据库中获取块<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchBlockFromDB</span><span class="params">(blockNumber uint64)</span></span> (*protos.<span class="type">Block</span>, error) &#123;</span><br><span class="line">	blockBytes, err := db.<span class="type">GetDBHandle</span>().<span class="type">GetFromBlockchainCF</span>(encodeBlockNumberDBKey(blockNumber))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> blockBytes == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> protos.<span class="type">UnmarshallBlock</span>(blockBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fetchTransactionFromDB">fetchTransactionFromDB</h2><p>从数据库中获取交易记录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> fetchTransactionFromDB(blockNum <span class="typename">uint64</span>, txIndex <span class="typename">uint64</span>) (*protos.Transaction, error) &#123;</span><br><span class="line">	block, err := fetchBlockFromDB(blockNum)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block.GetTransactions()[txIndex], <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fetchBlockchainSizeFromDB">fetchBlockchainSizeFromDB</h2><p>从数据库中获取区块链的大小<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchBlockchainSizeFromDB</span><span class="params">()</span></span> (uint64, error) &#123;</span><br><span class="line">	bytes, err := db.<span class="type">GetDBHandle</span>().<span class="type">GetFromBlockchainCF</span>(blockCountKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bytes == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> decodeToUint64(bytes), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fetchBlockchainSizeFromSnapshot">fetchBlockchainSizeFromSnapshot</h2><p>从快照中获取区块链大小<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> fetchBlockchainSizeFromSnapshot(snapshot *gorocksdb.Snapshot) (<span class="typename">uint64</span>, error) &#123;</span><br><span class="line">	blockNumberBytes, err := db.GetDBHandle().GetFromBlockchainCFSnapshot(snapshot, blockCountKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> blockNumber <span class="typename">uint64</span></span><br><span class="line">	<span class="keyword">if</span> blockNumberBytes != <span class="constant">nil</span> &#123;</span><br><span class="line">		blockNumber = decodeToUint64(blockNumberBytes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blockNumber, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="String">String</h2><p>将区块链的信息以字符串形式输出<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">func (blockchain *blockchain) <span class="function">String</span>() string &#123;</span><br><span class="line">	<span class="tag">var</span> buffer bytes<span class="class">.Buffer</span></span><br><span class="line">	size <span class="value">:= blockchain.<span class="function">getSize</span>()</span><br><span class="line">	for i := <span class="function">uint64</span>(<span class="number">0</span>);</span> <span class="tag">i</span> &lt; size; <span class="tag">i</span>++ &#123;</span><br><span class="line">		<span class="value">block</span>, blockErr <span class="value">:= blockchain.<span class="function">getBlock</span>(i)</span><br><span class="line">		if blockErr != nil &#123;</span><br><span class="line">			return <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">		buffer.<span class="function">WriteString</span>(<span class="string">"\n----------&lt;block #"</span>)</span><br><span class="line">		buffer.<span class="function">WriteString</span>(strconv.<span class="function">FormatUint</span>(i, <span class="number">10</span>))</span><br><span class="line">		buffer.<span class="function">WriteString</span>(<span class="string">"&gt;----------\n"</span>)</span><br><span class="line">		buffer.<span class="function">WriteString</span>(block.<span class="function">String</span>())</span><br><span class="line">		buffer.<span class="function">WriteString</span>(<span class="string">"\n----------&lt;\\block #"</span>)</span><br><span class="line">		buffer.<span class="function">WriteString</span>(strconv.<span class="function">FormatUint</span>(i, <span class="number">10</span>))</span><br><span class="line">		buffer.<span class="function">WriteString</span>(<span class="string">"&gt;----------\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	return buffer.<span class="function">String</span>()</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="blockchain_indexes">blockchain_indexes</h1><p>blockchainIndexer定义了以下几个接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> blockchainIndexer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//同步标识</span></span><br><span class="line">	isSynchronous() <span class="typename">bool</span></span><br><span class="line">	<span class="comment">//开始创建</span></span><br><span class="line">	start(blockchain *blockchain) error</span><br><span class="line">	<span class="comment">//同步创建索引</span></span><br><span class="line">	createIndexesSync(block *protos.Block, blockNumber <span class="typename">uint64</span>, blockHash []<span class="typename">byte</span>, writeBatch *gorocksdb.WriteBatch) error</span><br><span class="line">	<span class="comment">//异步创建索引</span></span><br><span class="line">	createIndexesAsync(block *protos.Block, blockNumber <span class="typename">uint64</span>, blockHash []<span class="typename">byte</span>) error</span><br><span class="line">	<span class="comment">//通过块哈希获取块号</span></span><br><span class="line">	fetchBlockNumberByBlockHash(blockHash []<span class="typename">byte</span>) (<span class="typename">uint64</span>, error)</span><br><span class="line">	<span class="comment">//通过UUID获取块号</span></span><br><span class="line">	fetchTransactionIndexByUUID(txUUID <span class="typename">string</span>) (<span class="typename">uint64</span>, <span class="typename">uint64</span>, error)</span><br><span class="line">	<span class="comment">//停止创建</span></span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="addIndexDataForPersistence">addIndexDataForPersistence</h2><p>持久化并且检索索引数据<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> <span class="keyword">addIndexDataForPersistence(block </span>*protos.<span class="keyword">Block, </span><span class="keyword">blockNumber </span>uint64, <span class="keyword">blockHash </span>[]<span class="keyword">byte, </span>writeBatch *gorocksdb.WriteBatch) error &#123;</span><br><span class="line">	openchainDB := db.GetDBHandle()</span><br><span class="line">	cf := openchainDB.IndexesCF</span><br><span class="line"></span><br><span class="line">	// 块号映射成块哈希值</span><br><span class="line">	indexLogger.Debug(<span class="string">"Indexing block number [%d] by hash = [%x]"</span>, <span class="keyword">blockNumber, </span><span class="keyword">blockHash)</span><br><span class="line"></span>	writeBatch.PutCF(cf, encodeBlockHashKey(<span class="keyword">blockHash), </span>encodeBlockNumber(<span class="keyword">blockNumber))</span><br><span class="line"></span></span><br><span class="line">	<span class="keyword">addressToTxIndexesMap </span>:= make(<span class="preprocessor">map</span>[<span class="keyword">string][]uint64)</span><br><span class="line"></span>	<span class="keyword">addressToChaincodeIDsMap </span>:= make(<span class="preprocessor">map</span>[<span class="keyword">string][]*protos.ChaincodeID)</span><br><span class="line"></span></span><br><span class="line">	transactions := <span class="keyword">block.GetTransactions()</span><br><span class="line"></span>	for txIndex, tx := range transactions &#123;</span><br><span class="line">		// 添加TXT UUID - &gt;（块号，索引中块）</span><br><span class="line">		writeBatch.PutCF(cf, encodeTxUUIDKey(tx.Uuid), encodeBlockNumTxIndex(<span class="keyword">blockNumber, </span>uint64(txIndex)))</span><br><span class="line"></span><br><span class="line">		txExecutingAddress := getTxExecutingAddress(tx)</span><br><span class="line">		<span class="keyword">addressToTxIndexesMap[txExecutingAddress] </span>= append(<span class="keyword">addressToTxIndexesMap[txExecutingAddress], </span>uint64(txIndex))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch </span>tx.Type &#123;</span><br><span class="line">		case protos.Transaction_CHAINCODE_NEW, protos.Transaction_CHAINCODE_UPDATE:</span><br><span class="line">			authroizedAddresses, chaincodeID := getAuthorisedAddresses(tx)</span><br><span class="line">			for _, authroizedAddress := range authroizedAddresses &#123;</span><br><span class="line">				<span class="keyword">addressToChaincodeIDsMap[authroizedAddress] </span>= append(<span class="keyword">addressToChaincodeIDsMap[authroizedAddress], </span>chaincodeID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for <span class="keyword">address, </span>txsIndexes := range <span class="keyword">addressToTxIndexesMap </span>&#123;</span><br><span class="line">		writeBatch.PutCF(cf, encodeAddressBlockNumCompositeKey(<span class="keyword">address, </span><span class="keyword">blockNumber), </span>encodeListTxIndexes(txsIndexes))</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getAuthorisedAddresses">getAuthorisedAddresses</h2><p>获得授权地址<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> getAuthorisedAddresses(tx *protos.Transaction) ([]<span class="typename">string</span>, *protos.ChaincodeID) &#123;</span><br><span class="line">	<span class="comment">// 从chaincode的部署TX中获取取地址</span></span><br><span class="line">	<span class="comment">// 这个方法也会返回错误</span></span><br><span class="line">	data := tx.ChaincodeID</span><br><span class="line">	cID := &amp;protos.ChaincodeID&#123;&#125;</span><br><span class="line">	err := proto.Unmarshal(data, cID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="typename">string</span>&#123;<span class="string">"address1"</span>, <span class="string">"address2"</span>&#125;, cID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="encodeBlockNumber">encodeBlockNumber</h2><p>编码/解码数据库键/值函数，索引数据编码/解码块数<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="label">func</span> encodeBlockNumber(<span class="keyword">blockNumber </span>uint64) []<span class="keyword">byte </span>&#123;</span><br><span class="line">	return proto.EncodeVarint(<span class="keyword">blockNumber)</span><br><span class="line"></span>&#125;</span><br><span class="line"><span class="label">func</span> decodeBlockNumber(<span class="keyword">blockNumberBytes </span>[]<span class="keyword">byte) </span>(<span class="keyword">blockNumber </span>uint64) &#123;</span><br><span class="line">	<span class="keyword">blockNumber, </span>_ = proto.DecodeVarint(<span class="keyword">blockNumberBytes)</span><br><span class="line"></span>	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="encodeBlockNumTxIndex">encodeBlockNumTxIndex</h2><p>对 块号的Tx索引进行编码/解码<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> encodeBlockNumTxIndex(<span class="keyword">blockNumber </span>uint64, txIndexInBlock uint64) []<span class="keyword">byte </span>&#123;</span><br><span class="line">	<span class="keyword">b </span>:= proto.NewBuffer([]<span class="keyword">byte&#123;&#125;)</span><br><span class="line"></span>	<span class="keyword">b.EncodeVarint(blockNumber)</span><br><span class="line"></span>	<span class="keyword">b.EncodeVarint(txIndexInBlock)</span><br><span class="line"></span>	return <span class="keyword">b.Bytes()</span><br><span class="line"></span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">func</span> decodeBlockNumTxIndex(<span class="keyword">bytes </span>[]<span class="keyword">byte) </span>(<span class="keyword">blockNum </span>uint64, txIndex uint64, err error) &#123;</span><br><span class="line">	<span class="keyword">b </span>:= proto.NewBuffer(<span class="keyword">bytes)</span><br><span class="line"></span>	<span class="keyword">blockNum, </span>err = <span class="keyword">b.DecodeVarint()</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	txIndex, err = <span class="keyword">b.DecodeVarint()</span><br><span class="line"></span>	<span class="preprocessor">if</span> err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对区块哈希的键值进行编码<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="label">func</span> encodeBlockHashKey(<span class="keyword">blockHash </span>[]<span class="keyword">byte) </span>[]<span class="keyword">byte </span>&#123;</span><br><span class="line">	return prependKeyPrefix(prefixBlockHashKey, <span class="keyword">blockHash)</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>对TxUUID的键值进行编码</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">encodeTxUUIDKey</span>(<span class="params">txUUID <span class="keyword">string</span></span>) []<span class="keyword">byte</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prependKeyPrefix(prefixTxUUIDKey, []<span class="keyword">byte</span>(txUUID))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对区块号地址的复合键值进行编码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">func</span> <span class="tag">encodeAddressBlockNumCompositeKey</span>(<span class="tag">address</span> <span class="tag">string</span>, <span class="tag">blockNumber</span> <span class="tag">uint64</span>) <span class="attr_selector">[]</span><span class="tag">byte</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">b </span>:<span class="value">= proto.<span class="function">NewBuffer</span>([]byte&#123;prefixAddressBlockNumCompositeKey</span></span></span>&#125;)</span><br><span class="line">	<span class="tag">b</span><span class="class">.EncodeRawBytes</span>(<span class="attr_selector">[]</span><span class="tag">byte</span>(<span class="tag">address</span>))</span><br><span class="line">	<span class="tag">b</span><span class="class">.EncodeVarint</span>(<span class="tag">blockNumber</span>)</span><br><span class="line">	<span class="tag">return</span> <span class="tag">b</span><span class="class">.Bytes</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对Tx的索引清单进行编码<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> encodeListTxIndexes(listTx []<span class="typename">uint64</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	b := proto.NewBuffer([]<span class="typename">byte</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> listTx &#123;</span><br><span class="line">		b.EncodeVarint(listTx[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对chaincode的ID进行编码<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">func</span> <span class="tag">encodeChaincodeID</span>(c *protos.ChaincodeID) <span class="attr_selector">[]</span><span class="tag">byte</span> &#123;</span><br><span class="line">	<span class="comment">// 序列化chaincode ID</span></span><br><span class="line">	<span class="tag">return</span> <span class="attr_selector">[]</span><span class="tag">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前置键值前缀</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">func prependKeyPrefix(prefix <span class="built_in">byte</span>, <span class="variable">key</span> []<span class="built_in">byte</span>) []<span class="built_in">byte</span> &#123;</span><br><span class="line">	modifiedKey := []<span class="built_in">byte</span>&#123;&#125;</span><br><span class="line">	modifiedKey = <span class="built_in">append</span>(modifiedKey, prefix)</span><br><span class="line">	modifiedKey = <span class="built_in">append</span>(modifiedKey, <span class="variable">key</span>...)</span><br><span class="line">	<span class="keyword">return</span> modifiedKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="blockchain_indexes_async">blockchain_indexes_async</h1><p>整个代码主要执行对blockchain的异步创建索引<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">type</span> <span class="keyword">blockchainIndexerAsync </span><span class="keyword">struct </span>&#123;</span><br><span class="line">	<span class="keyword">blockchain </span>*<span class="keyword">blockchain</span><br><span class="line"></span>	//从块链转移块索引的通道</span><br><span class="line">	<span class="keyword">blockChan </span>   chan <span class="keyword">blockWrapper</span><br><span class="line"></span>	indexerState *<span class="keyword">blockchainIndexerState</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="createIndexesInternal">createIndexesInternal</h2><p>创建索引条目并逐步添加到数据库，用于创建各种属性的索引<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">func</span> (<span class="tag">indexer</span> *<span class="tag">blockchainIndexerAsync</span>) <span class="tag">createIndexesInternal</span>(<span class="tag">block</span> *<span class="tag">protos</span><span class="class">.Block</span>, <span class="tag">blockNumber</span> <span class="tag">uint64</span>, <span class="tag">blockHash</span> <span class="attr_selector">[]</span><span class="tag">byte</span>) <span class="tag">error</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">openchainDB </span>:<span class="value">= db.<span class="function">GetDBHandle</span>()</span><br><span class="line">	writeBatch := gorocksdb.<span class="function">NewWriteBatch</span>()</span><br><span class="line">	defer writeBatch.<span class="function">Destroy</span>()</span><br><span class="line">	<span class="function">addIndexDataForPersistence</span>(block, blockNumber, blockHash, writeBatch)</span><br><span class="line">	writeBatch.<span class="function">PutCF</span>(openchainDB.IndexesCF, lastIndexedBlockKey, <span class="function">encodeBlockNumber</span>(blockNumber))</span><br><span class="line">	opt := gorocksdb.<span class="function">NewDefaultWriteOptions</span>()</span><br><span class="line">	defer opt.<span class="function">Destroy</span>()</span><br><span class="line">	err := openchainDB.DB.<span class="function">Write</span>(opt, writeBatch)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">	<span class="tag">indexer</span><span class="class">.indexerState</span><span class="class">.blockIndexed</span>(<span class="tag">blockNumber</span>)</span><br><span class="line">	<span class="tag">return</span> <span class="tag">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="indexPendingBlocks">indexPendingBlocks</h2><p>待定块的索引<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(indexer *blockchainIndexerAsync)</span></span> indexPendingBlocks() error &#123;</span><br><span class="line">	blockchain := indexer.blockchain</span><br><span class="line">	<span class="keyword">if</span> blockchain.getSize() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 链至今为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastCommittedBlockNum := blockchain.getSize() - <span class="number">1</span></span><br><span class="line">	lastIndexedBlockNum := indexer.indexerState.getLastIndexedBlockNumber()</span><br><span class="line">	<span class="keyword">if</span> lastCommittedBlockNum == lastIndexedBlockNum &#123;</span><br><span class="line">		<span class="comment">//所有块索引的提交</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; lastIndexedBlockNum &lt; lastCommittedBlockNum; lastIndexedBlockNum++ &#123;</span><br><span class="line">		blockNumToIndex := lastIndexedBlockNum + <span class="number">1</span></span><br><span class="line">		blockToIndex, errBlockFetch := blockchain.getBlock(blockNumToIndex)</span><br><span class="line">		<span class="keyword">if</span> errBlockFetch != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errBlockFetch</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		blockHash, errBlockHash := blockToIndex.<span class="type">GetHash</span>()</span><br><span class="line">		<span class="keyword">if</span> errBlockHash != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errBlockHash</span><br><span class="line">		&#125;</span><br><span class="line">		indexer.createIndexesInternal(blockToIndex, blockNumToIndex, blockHash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="blockIndexed">blockIndexed</h2><p>块索引<br><figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line"><span class="component">func (indexerState *blockchainIndexerState) blockIndexed(blockNumber uint64) &#123;</span><br><span class="line">	indexerState<span class="string">.newBlockIndexed.L.Lock()</span></span><br><span class="line">	defer indexerState<span class="string">.newBlockIndexed.L.Unlock()</span></span><br><span class="line">	indexerState<span class="string">.lastBlockIndexed</span> = blockNumber</span><br><span class="line">	indexerState<span class="string">.zerothBlockIndexed</span> = true</span><br><span class="line">	indexerState<span class="string">.newBlockIndexed.Broadcast()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="waitForLastCommittedBlock">waitForLastCommittedBlock</h2><p>等待最后一个块的创建<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (indexerState *blockchainIndexerState) waitForLastCommittedBlock() (err <span class="keyword">error</span>) &#123;</span><br><span class="line">	chain := indexerState.indexer.blockchain</span><br><span class="line">	<span class="keyword">if</span> err != nil || chain.getSize() == 0 &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastBlockCommitted := chain.getSize() - 1</span><br><span class="line"></span><br><span class="line">	indexerState.newBlockIndexed.L.Lock()</span><br><span class="line">	defer indexerState.newBlockIndexed.L.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !indexerState.zerothBlockIndexed &#123;</span><br><span class="line">		indexLogger.Debug(</span><br><span class="line">			<span class="string">"Waiting for zeroth block to be indexed. lastBlockCommitted=[%d] and lastBlockIndexed=[%d]"</span>,</span><br><span class="line">			lastBlockCommitted, indexerState.lastBlockIndexed)</span><br><span class="line">		indexerState.newBlockIndexed.Wait()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> indexerState.lastBlockIndexed &lt; lastBlockCommitted &#123;</span><br><span class="line">		indexLogger.Debug(</span><br><span class="line">			<span class="string">"Waiting for index to catch up with block chain. lastBlockCommitted=[%d] and lastBlockIndexed=[%d]"</span>,</span><br><span class="line">			lastBlockCommitted, indexerState.lastBlockIndexed)</span><br><span class="line">		indexerState.newBlockIndexed.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fetchLastIndexedBlockNumFromDB">fetchLastIndexedBlockNumFromDB</h2><p>获取从数据库中得到上一个块号的块索引<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> fetchLastIndexedBlockNumFromDB() (zerothBlockIndexed <span class="typename">bool</span>, lastIndexedBlockNum <span class="typename">uint64</span>, err error) &#123;</span><br><span class="line">	lastIndexedBlockNumberBytes, err := db.GetDBHandle().GetFromIndexesCF(lastIndexedBlockKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lastIndexedBlockNumberBytes == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lastIndexedBlockNum = decodeBlockNumber(lastIndexedBlockNumberBytes)</span><br><span class="line">	zerothBlockIndexed = <span class="constant">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ledger">ledger</h1><p>先看下ledger的结构<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">type Ledger struct &#123;</span><br><span class="line">	blockchain *blockchain //区块链</span><br><span class="line">	<span class="keyword">state</span>      *<span class="keyword">state</span>.State //状态</span><br><span class="line">	currentID  interface&#123;&#125; //当前ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetLedger">GetLedger</h2><p>给出”单个“ledger的引用<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLedger</span><span class="params">()</span> <span class="params">(*Ledger, error)</span> &#123;</span></span><br><span class="line">	once.<span class="keyword">Do</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span> &#123;</span></span><br><span class="line">		ledger, ledgerError = newLedger()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ledger, ledgerError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BeginTxBatch">BeginTxBatch</h2><p>开始批量发出</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span></span> <span class="type">BeginTxBatch</span>(id interface&#123;&#125;) error &#123;</span><br><span class="line">	err := ledger.checkValidIDBegin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	ledger.currentID = id</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GetTXBatchPreviewBlock">GetTXBatchPreviewBlock</h2><p>返回将具有相同块的哈希，如果ledger.CommitTxBatch使用相同的参数则提交到数据库。如果该状态是由一个事务这两个调用之间修改，散列将不同。该块预览不包括非散列数据，如本地时间戳。<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) GetTXBatchPreviewBlock(id interface&#123;&#125;,</span><br><span class="line">	transactions []*protos.Transaction, metadata []byte) (*protos.Block, error) &#123;</span><br><span class="line">	err := ledger.checkValidIDCommitORRollback(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>Hash, err := ledger.<span class="keyword">state</span>.GetHash()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return ledger.blockchain.buildBlock(protos.NewBlock(transactions, metadata), <span class="keyword">state</span>Hash), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CommitTxBatch">CommitTxBatch</h2><p>CommitTxBatch被调用时，当前事务需要分批次提交，该函数成功返回了交易的细节和状态变化（可能在这个交易批量的执行过程中发生）一直致力于持久化存储</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) CommitTxBatch(id <span class="class"><span class="keyword">interface</span></span>&#123;&#125;, transactions []*protos.Transaction, transactionResults []*protos.TransactionResult, metadata []<span class="keyword">byte</span>) <span class="keyword">error</span> &#123;</span><br><span class="line">	err := ledger.checkValidIDCommitORRollback(id)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stateHash, err := ledger.state.GetHash()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		ledger.resetForNextTxGroup(<span class="keyword">false</span>)</span><br><span class="line">		ledger.blockchain.blockPersistenceStatus(<span class="keyword">false</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	writeBatch := gorocksdb.NewWriteBatch()</span><br><span class="line">	defer writeBatch.Destroy()</span><br><span class="line">	block := protos.NewBlock(transactions, metadata)</span><br><span class="line">	block.NonHashData = &amp;protos.NonHashData&#123;TransactionResults: transactionResults&#125;</span><br><span class="line">	newBlockNumber, err := ledger.blockchain.addPersistenceChangesForNewBlock(context.TODO(), block, stateHash, writeBatch)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		ledger.resetForNextTxGroup(<span class="keyword">false</span>)</span><br><span class="line">		ledger.blockchain.blockPersistenceStatus(<span class="keyword">false</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	ledger.state.AddChangesForPersistence(newBlockNumber, writeBatch)</span><br><span class="line">	opt := gorocksdb.NewDefaultWriteOptions()</span><br><span class="line">	defer opt.Destroy()</span><br><span class="line">	dbErr := db.GetDBHandle().DB.Write(opt, writeBatch)</span><br><span class="line">	<span class="keyword">if</span> dbErr != nil &#123;</span><br><span class="line">		ledger.resetForNextTxGroup(<span class="keyword">false</span>)</span><br><span class="line">		ledger.blockchain.blockPersistenceStatus(<span class="keyword">false</span>)</span><br><span class="line">		<span class="keyword">return</span> dbErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledger.resetForNextTxGroup(<span class="keyword">true</span>)</span><br><span class="line">	ledger.blockchain.blockPersistenceStatus(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line">	sendProducerBlockEvent(block)</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RollbackTxBatch">RollbackTxBatch</h2><p>批处理回滚时放弃当前事务批次执行过程中可能发生的所有状态变化<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) RollbackTxBatch(<span class="keyword">id</span> interface&#123;&#125;) error &#123;</span><br><span class="line">	ledgerLogger<span class="variable">.Debug</span>(<span class="string">"RollbackTxBatch for id = [%s]"</span>, <span class="keyword">id</span>)</span><br><span class="line">	err := ledger<span class="variable">.checkValidIDCommitORRollback</span>(<span class="keyword">id</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	ledger<span class="variable">.resetForNextTxGroup</span>(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="TxBegin">TxBegin</h2><p>标志着在持续一批新的交易开始<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) TxBegin(txUUID string) &#123;</span><br><span class="line">	ledger.<span class="keyword">state</span>.TxBegin(txUUID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="TxFinished">TxFinished</h2><p>标志着正在进行交易的完成。如果成功话设置为false，丢弃事务的状态变化<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) TxFinished(txUUID string, txSuccessful bool) &#123;</span><br><span class="line">	ledger.<span class="keyword">state</span>.TxFinish(txUUID, txSuccessful)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetTempStateHash">GetTempStateHash</h2><p>计算哈希状态并考虑到当前事务批次执行过程中可能发生的状态变化<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span> <span class="title">GetTempStateHash</span><span class="params">()</span> <span class="params">([]byte, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> ledger.state.GetHash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetTempStateHashWithTxDeltaStateHashes">GetTempStateHashWithTxDeltaStateHashes</h2><p>除状态散列（如在方法GetTempStateHash定义），<br>此方法返回一个映射[TX的txUuid - &gt; cryptoHash（stateChange MadeBySIx），只有TX成功，才会出现在该映射中<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) GetTempStateHashWithTxDeltaStateHashes() ([<span class="link_label"></span>]byte, map[<span class="link_label">string</span>][<span class="link_reference"></span>]byte, error) &#123;</span><br><span class="line"><span class="code">	stateHash, err := ledger.state.GetHash()</span></span><br><span class="line"><span class="code">	return stateHash, ledger.state.GetTxStateDeltaHash(), err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetState">GetState</h2><p>获取chaincode的id和键值。如果提交为false，它首先会在内存中查看。如果丢失的话，将从数据库中获取。如果提交为true，则仅仅只能在数据库中获取。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span> <span class="title">GetState</span><span class="params">(chaincodeID string, key string, committed bool)</span> <span class="params">([]byte, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> ledger.state.Get(chaincodeID, key, committed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GetStateRangeScanIterator">GetStateRangeScanIterator</h2><p>返回一个迭代器来获取所有startKey和endKey之间的键（和值）（假设键的词汇顺序）为chaincodeID。如果提交为true，则从数据库检索的键值是唯一。如果提交为false，从数据库被mergerd后的结果与在存储器中的结果（优先考虑在内存中的数据）在返回的迭代的键值是不同的<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"> guaranteed <span class="keyword">to</span> be <span class="keyword">in</span> any specific order</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span> <span class="title">GetStateRangeScanIterator</span><span class="params">(chaincodeID string, startKey string, endKey string, committed bool)</span> <span class="params">(statemgmt.RangeScanIterator, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> ledger.state.GetRangeScanIterator(chaincodeID, startKey, endKey, committed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetStateSnapshot">GetStateSnapshot</h2><p>返回当前块点对点全局状态。 这个是在从一个端到另一个端转化中的状态时使用。必须调用状态Snapshot.Release（）方法一旦你与快照是以释放资源完成的。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (ledger *Ledger) GetStateSnapshot() (*<span class="keyword">state</span>.StateSnapshot, error) &#123;</span><br><span class="line">	dbSnapshot := db.GetDBHandle().GetSnapshot()</span><br><span class="line">	<span class="built_in">block</span>Height, err := fetchBlockchainSizeFromSnapshot(dbSnapshot)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		dbSnapshot.Release()</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if <span class="number">0</span> == <span class="built_in">block</span>Height &#123;</span><br><span class="line">		dbSnapshot.Release()</span><br><span class="line">		return nil, fmt.Errorf(<span class="string">"Blockchain has no blocks, cannot determine block number"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	return ledger.<span class="keyword">state</span>.GetSnapshot(<span class="built_in">block</span>Height-<span class="number">1</span>, dbSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GetStateDelta">GetStateDelta</h2><p>如果可用，则返回指定块的状态增量。<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span> <span class="title">GetStateDelta</span><span class="params">(blockNumber uint64)</span> <span class="params">(*statemgmt.StateDelta, error)</span> &#123;</span></span><br><span class="line">	<span class="keyword">if</span> blockNumber &gt;= ledger.GetBlockchainSize() &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, ErrOutOfBounds</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ledger.state.FetchStateDeltaFromDB(blockNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ApplyStateDelta">ApplyStateDelta</h2><p>即适用于一个当前的状态状态增量。它只在内存改变。必须调用ledger.CommitStateDelta持久化到数据库。这应该只被用来作为状态同步的一部分。状态增量可以从另一对等虽然Ledger.GetStateDelta函数检索或者与来自Ledger.GetStateshot()获取密钥创​​建的状态增量。举一个例子，在ledger_test.go定义的TestSetRawState。请注意，没有在此功能上检查它是否被调用，以确保增量是在正确的顺序中使用。例如，如果你目前正处于块8，并调用Ledger.GetStateDelta（10）的功能检索增量，您现在会是在一个糟糕的状态，因为你没有块9.申请增量这是可能的回滚状态向前或向后使用stateDelta.RollBackwards。默认情况下，块3检索的增量可以被用来从状态向前回滚在块2到状态在块3.如果<br>stateDelta.RollBackwards =false，增量检索块3可用于向后滚动块3状态和块2的状态。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span></span> <span class="type">ApplyStateDelta</span>(id interface&#123;&#125;, delta *statemgmt.<span class="type">StateDelta</span>) error &#123;</span><br><span class="line">	err := ledger.checkValidIDBegin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	ledger.currentID = id</span><br><span class="line">	ledger.state.<span class="type">ApplyStateDelta</span>(delta)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CommitStateDelta">CommitStateDelta</h2><p>将提交ledger.ApplyState状态增量并传递到到数据库<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">func</span> (<span class="tag">ledger</span> *<span class="tag">Ledger</span>) <span class="tag">CommitStateDelta</span>(<span class="tag">id</span> <span class="tag">interface</span><span class="rules">&#123;&#125;</span>) <span class="tag">error</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">err </span>:<span class="value">= ledger.<span class="function">checkValidIDCommitORRollback</span>(id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">	<span class="tag">defer</span> <span class="tag">ledger</span><span class="class">.resetForNextTxGroup</span>(<span class="tag">true</span>)</span><br><span class="line">	<span class="tag">return</span> <span class="tag">ledger</span><span class="class">.state</span><span class="class">.CommitStateDelta</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RollbackStateDelta">RollbackStateDelta</h2><p>放弃到ledger.ApplyStateDelta状态增量<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ledger *Ledger)</span></span> <span class="type">RollbackStateDelta</span>(id interface&#123;&#125;) error &#123;</span><br><span class="line">	err := ledger.checkValidIDCommitORRollback(id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	ledger.resetForNextTxGroup(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="VerifyChain">VerifyChain</h2><p>将验证blockchain的integrety。完成这一步<br>通过确保存储在每个块中的前一个块的哈希链中的前块的实际散列相匹配。返回值是包含不匹配的前一个块的散列块的块号。例如，如果验证链（0，99）称为与prevous哈希值存储在块8中，32和42不相匹配各自前块42的实际的哈希值将是从该函数的返回值。 highBlock在链中高级验证。 如果你要验证的整个链条中，使用ledger.GetBlockchainsize（） - 1。低块是在链中被低级验证。如果您想验证整个链条，为创世区块使用0。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (ledger *Ledger) VerifyChain(highBlock, lowBlock <span class="typename">uint64</span>) (<span class="typename">uint64</span>, error) &#123;</span><br><span class="line">	<span class="keyword">if</span> highBlock &gt;= ledger.GetBlockchainSize() &#123;</span><br><span class="line">		<span class="keyword">return</span> highBlock, ErrOutOfBounds</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> highBlock &lt;= lowBlock &#123;</span><br><span class="line">		<span class="keyword">return</span> lowBlock, ErrOutOfBounds</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := highBlock; i &gt; lowBlock; i-- &#123;</span><br><span class="line">		currentBlock, err := ledger.GetBlockByNumber(i)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, fmt.Errorf(<span class="string">"Error fetching block %d."</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> currentBlock == <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, fmt.Errorf(<span class="string">"Block %d is nil."</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		previousBlock, err := ledger.GetBlockByNumber(i - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i - <span class="number">1</span>, fmt.Errorf(<span class="string">"Error fetching block %d."</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> previousBlock == <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i - <span class="number">1</span>, fmt.Errorf(<span class="string">"Block %d is nil."</span>, i-<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		previousBlockHash, err := previousBlock.GetHash()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i - <span class="number">1</span>, fmt.Errorf(<span class="string">"Error calculating block hash for block %d."</span>, i-<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> bytes.Compare(previousBlockHash, currentBlock.PreviousBlockHash) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="constant">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sendProducerBlockEvent">sendProducerBlockEvent</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">func sendProducerBlockEvent(block *protos.Block) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从部署删除交易的有效载荷。这样做是为了创建块</span></span><br><span class="line">	<span class="comment">//这些类型的交易使事件更轻巧，有效载荷有可能非常大</span></span><br><span class="line">	blockTransactions := block.GetTransactions()</span><br><span class="line">	<span class="keyword">for</span> _, transaction := <span class="keyword">range</span> blockTransactions &#123;</span><br><span class="line">		<span class="keyword">if</span> transaction.<span class="keyword">Type</span> == protos.Transaction_CHAINCODE_NEW &#123;</span><br><span class="line">			deploymentSpec := &amp;protos.ChaincodeDeploymentSpec&#123;&#125;</span><br><span class="line">			<span class="keyword">err</span> := proto.Unmarshal(transaction.Payload, deploymentSpec)</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				ledgerLogger.<span class="keyword">Error</span>(fmt.Sprintf(<span class="string">"Error unmarshalling deployment transaction for block event: %s"</span>, <span class="keyword">err</span>))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			deploymentSpec.CodePackage = nil</span><br><span class="line">			deploymentSpecBytes, <span class="keyword">err</span> := proto.Marshal(deploymentSpec)</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				ledgerLogger.<span class="keyword">Error</span>(fmt.Sprintf(<span class="string">"Error marshalling deployment transaction for block event: %s"</span>, <span class="keyword">err</span>))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			transaction.Payload = deploymentSpecBytes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	producer.Send(producer.CreateBlockEvent(block))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="genesis">genesis</h1><p>类似于chaincode，调用go-logging中logging库的MustGetLogger函数对genesis package进行记录</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="tag">var</span> genesisLogger = logging.<span class="function"><span class="title">MustGetLogger</span><span class="params">(<span class="string">"genesis"</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="MakeGenesis">MakeGenesis</h2><p>MakeGenesis基于在openchain.yaml中配置创建创世区块，并把它添加到blockchain。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">func MakeGenesis() error &#123;</span><br><span class="line">	once.Do(func() &#123;</span><br><span class="line">		ledger, <span class="string">err :</span>= ledger.GetLedger()</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			makeGenesisError = err</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ledger.GetBlockchainSize() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 获取blockchain的大小，如果大于0代表创世区块已经存在</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		genesisLogger.Info(<span class="string">"Creating genesis block."</span>)</span><br><span class="line"></span><br><span class="line">		ledger.BeginTxBatch(<span class="number">0</span>)</span><br><span class="line">		var genesisTransactions []*protos.Transaction</span><br><span class="line">		<span class="comment">//我们现在禁用在有效期内部署，甚至不应该允许它在配置中启用，将其设置为false</span></span><br><span class="line">		<span class="string">allowDeployValidityPeriod :</span>= <span class="literal">false</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(deploySystemChaincodeEnabled() &amp;&amp; allowDeployValidityPeriod)&#123;</span><br><span class="line">			vpTransaction, <span class="string">deployErr :</span>=  deployUpdateValidityPeriodChaincode()</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> deployErr != nil &#123;</span><br><span class="line">				genesisLogger.Error(<span class="string">"Error deploying validity period system chaincode for genesis block."</span>, deployErr)</span><br><span class="line">				makeGenesisError = deployErr</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			genesisTransactions = append(genesisTransactions, vpTransaction)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="string">genesis :</span>= viper.GetStringMap(<span class="string">"ledger.blockchain.genesisBlock"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> genesis == nil &#123;</span><br><span class="line">			genesisLogger.Info(<span class="string">"No genesis block chaincodes defined."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			chaincodes, <span class="string">chaincodesOK :</span>= genesis[<span class="string">"chaincode"</span>].([]<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;)</span><br><span class="line">			<span class="keyword">if</span> !chaincodesOK &#123;</span><br><span class="line">				genesisLogger.Info(<span class="string">"No genesis block chaincodes defined."</span>)</span><br><span class="line">				ledger.CommitTxBatch(<span class="number">0</span>, genesisTransactions, nil, nil)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			genesisLogger.Debug(<span class="string">"Genesis chaincodes are %s"</span>, chaincodes)</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> <span class="string">i :</span>= <span class="number">0</span>; i &lt; len(chaincodes); i++ &#123;</span><br><span class="line">				genesisLogger.Debug(<span class="string">"Chaincode %d is %s"</span>, i, chaincodes[i])</span><br><span class="line">	</span><br><span class="line">				chaincodeMap, <span class="string">chaincodeMapOK :</span>= chaincodes[i].(map[<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;]<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;)</span><br><span class="line">				<span class="keyword">if</span> !chaincodeMapOK &#123;</span><br><span class="line">					genesisLogger.Error(<span class="string">"Invalid chaincode defined in genesis configuration:"</span>, chaincodes[i])</span><br><span class="line">					makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode defined in genesis configuration: %s"</span>, chaincodes[i])</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				path, <span class="string">pathOK :</span>= chaincodeMap[<span class="string">"path"</span>].(string)</span><br><span class="line">				<span class="keyword">if</span> !pathOK &#123;</span><br><span class="line">					genesisLogger.Error(<span class="string">"Invalid chaincode URL defined in genesis configuration:"</span>, chaincodeMap[<span class="string">"path"</span>])</span><br><span class="line">					makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode URL defined in genesis configuration: %s"</span>, chaincodeMap[<span class="string">"path"</span>])</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				chaincodeType, <span class="string">chaincodeTypeOK :</span>= chaincodeMap[<span class="string">"type"</span>].(string)</span><br><span class="line">				<span class="keyword">if</span> !chaincodeTypeOK &#123;</span><br><span class="line">					genesisLogger.Error(<span class="string">"Invalid chaincode type defined in genesis configuration:"</span>, chaincodeMap[<span class="string">"type"</span>])</span><br><span class="line">					makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode type defined in genesis configuration: %s"</span>, chaincodeMap[<span class="string">"type"</span>])</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				<span class="string">chaincodeID :</span>= &amp;protos.ChaincodeID&#123;<span class="string">Path:</span> path, <span class="string">Name:</span> <span class="string">""</span>&#125;</span><br><span class="line">	</span><br><span class="line">				genesisLogger.Debug(<span class="string">"Genesis chaincodeID %s"</span>, chaincodeID)</span><br><span class="line">				genesisLogger.Debug(<span class="string">"Genesis chaincode type %s"</span>, chaincodeType)</span><br><span class="line">	</span><br><span class="line">				constructorMap, <span class="string">constructorMapOK :</span>= chaincodeMap[<span class="string">"constructor"</span>].(map[<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;]<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;)</span><br><span class="line">				<span class="keyword">if</span> !constructorMapOK &#123;</span><br><span class="line">					genesisLogger.Error(<span class="string">"Invalid chaincode constructor defined in genesis configuration:"</span>, chaincodeMap[<span class="string">"constructor"</span>])</span><br><span class="line">					makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode constructor defined in genesis configuration: %s"</span>, chaincodeMap[<span class="string">"constructor"</span>])</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				var spec protos.ChaincodeSpec</span><br><span class="line">				<span class="keyword">if</span> constructorMap == nil &#123;</span><br><span class="line">					genesisLogger.Debug(<span class="string">"Genesis chaincode has no constructor."</span>)</span><br><span class="line">					spec = protos.ChaincodeSpec&#123;<span class="string">Type:</span> protos.ChaincodeSpec_Type(protos.ChaincodeSpec_Type_value[chaincodeType]), <span class="string">ChaincodeID:</span> chaincodeID&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	</span><br><span class="line">					ctorFunc, <span class="string">ctorFuncOK :</span>= constructorMap[<span class="string">"func"</span>].(string)</span><br><span class="line">					<span class="keyword">if</span> !ctorFuncOK &#123;</span><br><span class="line">						genesisLogger.Error(<span class="string">"Invalid chaincode constructor function defined in genesis configuration:"</span>, constructorMap[<span class="string">"func"</span>])</span><br><span class="line">						makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode constructor function args defined in genesis configuration: %s"</span>, constructorMap[<span class="string">"func"</span>])</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">					ctorArgs, <span class="string">ctorArgsOK :</span>= constructorMap[<span class="string">"args"</span>].([]<span class="class"><span class="keyword">interface</span>&#123;</span>&#125;)</span><br><span class="line">					<span class="keyword">if</span> !ctorArgsOK &#123;</span><br><span class="line">						genesisLogger.Error(<span class="string">"Invalid chaincode constructor args defined in genesis configuration:"</span>, constructorMap[<span class="string">"args"</span>])</span><br><span class="line">						makeGenesisError = fmt.Errorf(<span class="string">"Invalid chaincode constructor args defined in genesis configuration: %s"</span>, constructorMap[<span class="string">"args"</span>])</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">					genesisLogger.Debug(<span class="string">"Genesis chaincode constructor func %s"</span>, ctorFunc)</span><br><span class="line">					genesisLogger.Debug(<span class="string">"Genesis chaincode constructor args %s"</span>, ctorArgs)</span><br><span class="line">					var ctorArgsStringArray []string</span><br><span class="line">					<span class="keyword">for</span> <span class="string">j :</span>= <span class="number">0</span>; j &lt; len(ctorArgs); j++ &#123;</span><br><span class="line">						ctorArgsStringArray = append(ctorArgsStringArray, ctorArgs[j].(string))</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">					spec = protos.ChaincodeSpec&#123;<span class="string">Type:</span> protos.ChaincodeSpec_Type(protos.ChaincodeSpec_Type_value[chaincodeType]), <span class="string">ChaincodeID:</span> chaincodeID, <span class="string">CtorMsg:</span> &amp;protos.ChaincodeInput&#123;<span class="string">Function:</span> ctorFunc, <span class="string">Args:</span> ctorArgsStringArray&#125;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				transaction, _, <span class="string">deployErr :</span>= DeployLocal(context.Background(), &amp;spec)</span><br><span class="line">				<span class="keyword">if</span> deployErr != nil &#123;</span><br><span class="line">					genesisLogger.Error(<span class="string">"Error deploying chaincode for genesis block."</span>, deployErr)</span><br><span class="line">					makeGenesisError = deployErr</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">				genesisTransactions = append(genesisTransactions, transaction)</span><br><span class="line">	</span><br><span class="line">			&#125;<span class="comment">//for</span></span><br><span class="line"></span><br><span class="line">		&#125;<span class="comment">//else</span></span><br><span class="line"></span><br><span class="line">		genesisLogger.Info(<span class="string">"Adding %d system chaincodes to the genesis block."</span>, len(genesisTransactions))</span><br><span class="line">		ledger.CommitTxBatch(<span class="number">0</span>, genesisTransactions, nil, nil)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> makeGenesisError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BuildLocal">BuildLocal</h2><p>构建一个指定的chaincode码<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">func BuildLocal(context context.Context, spec *protos.ChaincodeSpec) (*protos.ChaincodeDeploymentSpec, <span class="keyword">error</span>) &#123;</span><br><span class="line">	genesisLogger.Debug(<span class="string">"Received build request for chaincode spec: %v"</span>, spec)</span><br><span class="line">	mode := viper.GetString(<span class="string">"chaincode.chaincoderunmode"</span>)</span><br><span class="line">	<span class="keyword">var</span> codePackageBytes []byte</span><br><span class="line">	<span class="keyword">if</span> mode != chaincode.DevModeUserRunsChaincode &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := openchain.CheckSpec(spec); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			genesisLogger.Debug(<span class="string">"check spec failed: %s"</span>, <span class="keyword">err</span>)</span><br><span class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 规范构建</span></span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></span><br><span class="line">		codePackageBytes, <span class="keyword">err</span> = container.GetChaincodePackageBytes(spec)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			genesisLogger.<span class="keyword">Error</span>(fmt.Sprintf(<span class="string">"Error getting VM: %s"</span>, <span class="keyword">err</span>))</span><br><span class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	chaincodeDeploymentSpec := &amp;protos.ChaincodeDeploymentSpec&#123;ChaincodeSpec: spec, CodePackage: codePackageBytes&#125;</span><br><span class="line">	<span class="keyword">return</span> chaincodeDeploymentSpec, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DeployLocal">DeployLocal</h2><p>部署供应链代码的映像到本地端</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">func <span class="type">DeployLocal</span>(ctx context.<span class="type">Context</span>, spec *protos.<span class="type">ChaincodeSpec</span>) (*protos.<span class="type">Transaction</span>, []byte, error) &#123;</span><br><span class="line">	// 首先建立并得到部署规范</span><br><span class="line">	chaincodeDeploymentSpec, err := <span class="type">BuildLocal</span>(ctx, spec)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;</span><br><span class="line">		genesisLogger.<span class="type">Error</span>(fmt.<span class="type">Sprintf</span>(<span class="string">"Error deploying chaincode spec: %v\n\n error: %s"</span>, spec, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">nil</span>, <span class="keyword">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	transaction, err := protos.<span class="type">NewChaincodeDeployTransaction</span>(chaincodeDeploymentSpec, chaincodeDeploymentSpec.<span class="type">ChaincodeSpec</span>.<span class="type">ChaincodeID</span>.<span class="type">Name</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">nil</span>, <span class="keyword">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"Error deploying chaincode: %s "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	//chaincode.<span class="type">NewChaincodeSupport</span>(chaincode.<span class="type">DefaultChain</span>, peer.<span class="type">GetPeerEndpoint</span>, <span class="literal">false</span>, <span class="number">120000</span>)</span><br><span class="line">	// secHelper设置在<span class="type">ChaincodeSupport</span>创建期间，因此我们不需要这一步</span><br><span class="line">	//ctx = context.<span class="type">WithValue</span>(ctx, <span class="string">"security"</span>, secCxt)</span><br><span class="line">	<span class="literal">result</span>, err := chaincode.<span class="type">Execute</span>(ctx, chaincode.<span class="type">GetChain</span>(chaincode.<span class="type">DefaultChain</span>), transaction)</span><br><span class="line">	<span class="keyword">return</span> transaction, <span class="literal">result</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置是否部署系统chaincode<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">deploySystemChaincodeEnabled</span><span class="params">()</span></span> bool &#123;</span><br><span class="line">	<span class="comment">// 如果系统chaincode的部署配置文件中能够返回所配置的值</span></span><br><span class="line">	<span class="keyword">if</span> viper.<span class="type">IsSet</span>(<span class="string">"ledger.blockchain.deploy-system-chaincode"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> viper.<span class="type">GetBool</span>(<span class="string">"ledger.blockchain.deploy-system-chaincode"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有指定配置能够启用，系统chaincode将采用默认情况部署</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deployUpdateValidityPeriodChaincode">deployUpdateValidityPeriodChaincode</h2><p>部署更新chaincode的有效期<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">func deployUpdateValidityPeriodChaincode() (*protos.Transaction, error) &#123;</span><br><span class="line">	<span class="comment">//它应该是可配置的，不采取硬编码</span></span><br><span class="line">	<span class="string">vpChaincodePath :</span>= <span class="string">"github.com/openblockchain/obc-peer/openchain/system_chaincode/validity_period_update"</span></span><br><span class="line">	<span class="string">vpFunction :</span>= <span class="string">"init"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这应该是负责有效期更新的组件的登录凭证。</span></span><br><span class="line">	<span class="comment">//该组件需要在系统中注册，以便能够调用更新chaincode的有效期</span></span><br><span class="line">	<span class="string">vpToken :</span>= <span class="string">"system_chaincode_invoker"</span></span><br><span class="line"></span><br><span class="line">	var vpCtorArgsStringArray []string</span><br><span class="line"></span><br><span class="line">	<span class="string">validityPeriodSpec :</span>= &amp;protos.ChaincodeSpec&#123;<span class="string">Type:</span> protos.ChaincodeSpec_GOLANG,</span><br><span class="line"><span class="label">		ChaincodeID:</span> &amp;protos.ChaincodeID&#123;<span class="string">Path:</span> vpChaincodePath,</span><br><span class="line"><span class="label">			Name:</span> <span class="string">""</span>,</span><br><span class="line">		&#125;,</span><br><span class="line"><span class="label">		CtorMsg:</span> &amp;protos.ChaincodeInput&#123;<span class="string">Function:</span> vpFunction,</span><br><span class="line"><span class="label">			Args:</span> vpCtorArgsStringArray,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	validityPeriodSpec.SecureContext = string(vpToken)</span><br><span class="line"></span><br><span class="line">	vpTransaction, _, <span class="string">deployErr :</span>= DeployLocal(context.Background(), validityPeriodSpec)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deployErr != nil &#123;</span><br><span class="line">		genesisLogger.Error(<span class="string">"Error deploying validity period chaincode for genesis block."</span>, deployErr)</span><br><span class="line">		makeGenesisError = deployErr</span><br><span class="line">		<span class="keyword">return</span> nil, deployErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vpTransaction, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="util">util</h1><h2 id="EncodeOrderPreservingVarUint64">EncodeOrderPreservingVarUint64</h2><p>返回一个字节表示要的int64数使得起始字节全零比特，以减少阵列的长度被修整，用于保存在一个缺省字节对比的顺序，第一个字节包含剩余的第一字节的bytes。存在的数量也允许使用返回的字节作为其它较大字节阵列的一部分，如以数据库复合键表示<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> EncodeOrderPreservingVarUint64(number <span class="typename">uint64</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	bytes := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="number">8</span>)</span><br><span class="line">	binary.BigEndian.PutUint64(bytes, number)</span><br><span class="line">	startingIndex := <span class="number">0</span></span><br><span class="line">	size := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> bytes &#123;</span><br><span class="line">		<span class="keyword">if</span> b != <span class="number">0x00</span> &#123;</span><br><span class="line">			startingIndex = i</span><br><span class="line">			size = <span class="number">8</span> - i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sizeBytes := proto.EncodeVarint(<span class="typename">uint64</span>(size))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(sizeBytes) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">"[]sizeBytes should not be more than one byte because the max number it needs to hold is 8. size=%d"</span>, size))</span><br><span class="line">	&#125;</span><br><span class="line">	encodedBytes := <span class="built_in">make</span>([]<span class="typename">byte</span>, size+<span class="number">1</span>)</span><br><span class="line">	encodedBytes[<span class="number">0</span>] = sizeBytes[<span class="number">0</span>]</span><br><span class="line">	<span class="built_in">copy</span>(encodedBytes[<span class="number">1</span>:], bytes[startingIndex:])</span><br><span class="line">	<span class="keyword">return</span> encodedBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DecodeOrderPreservingVarUint64">DecodeOrderPreservingVarUint64</h2><p>解码从由方法“EncodeOrderPreservingVarUint64’得到的字节数。<br>此外，返回在该过程中所消耗的字节数<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">func DecodeOrderPreservingVarUint64(bytes []<span class="built_in">byte</span>) (uint64, <span class="built_in">int</span>) &#123;</span><br><span class="line">	s, _ := proto.DecodeVarint(bytes)</span><br><span class="line">	<span class="built_in">size</span> := <span class="built_in">int</span>(s)</span><br><span class="line">	decodedBytes := make([]<span class="built_in">byte</span>, <span class="number">8</span>)</span><br><span class="line">	<span class="built_in">copy</span>(decodedBytes[<span class="number">8</span>-<span class="built_in">size</span>:], bytes[<span class="number">1</span>:<span class="built_in">size</span>+<span class="number">1</span>])</span><br><span class="line">	numBytesConsumed := <span class="built_in">size</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">binary</span>.BigEndian.Uint64(decodedBytes), numBytesConsumed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="buckettree">buckettree</h1><h2 id="bucket_hash">bucket_hash</h2><h3 id="addNextNode">addNextNode</h3><p>这个方法假定数据节点都按键的增加顺序添加<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *bucketHashCalculator)</span></span> addNextNode(dataNode *dataNode) &#123;</span><br><span class="line">	chaincodeID, <span class="number">_</span> := dataNode.getKeyElements()</span><br><span class="line">	<span class="keyword">if</span> chaincodeID != <span class="built_in">c</span>.currentChaincodeID &#123;</span><br><span class="line">		<span class="built_in">c</span>.appendCurrentChaincodeData()</span><br><span class="line">		<span class="built_in">c</span>.currentChaincodeID = chaincodeID</span><br><span class="line">		<span class="built_in">c</span>.dataNodes = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">c</span>.dataNodes = append(<span class="built_in">c</span>.dataNodes, dataNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="computeCryptoHash">computeCryptoHash</h3><p>计算加密哈希<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *bucketHashCalculator)</span></span> computeCryptoHash() []byte &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">c</span>.currentChaincodeID != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">c</span>.appendCurrentChaincodeData()</span><br><span class="line">		<span class="built_in">c</span>.currentChaincodeID = <span class="string">""</span></span><br><span class="line">		<span class="built_in">c</span>.dataNodes = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	logger.<span class="type">Debug</span>(<span class="string">"Hashable content for bucket [%s]: length=%d, contentInStringForm=[%s]"</span>, <span class="built_in">c</span>.bucketKey, len(<span class="built_in">c</span>.hashingData), string(<span class="built_in">c</span>.hashingData))</span><br><span class="line">	<span class="keyword">if</span> util.<span class="type">IsNil</span>(<span class="built_in">c</span>.hashingData) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> openchainUtil.<span class="type">ComputeCryptoHash</span>(<span class="built_in">c</span>.hashingData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="appendCurrentChaincodeData">appendCurrentChaincodeData</h3><p>添加当前chaincode数据<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *bucketHashCalculator)</span></span> appendCurrentChaincodeData() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">c</span>.currentChaincodeID == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">c</span>.appendSizeAndData([]byte(<span class="built_in">c</span>.currentChaincodeID))</span><br><span class="line">	<span class="built_in">c</span>.appendSize(len(<span class="built_in">c</span>.dataNodes))</span><br><span class="line">	<span class="keyword">for</span> <span class="number">_</span>, dataNode := range <span class="built_in">c</span>.dataNodes &#123;</span><br><span class="line">		<span class="number">_</span>, key := dataNode.getKeyElements()</span><br><span class="line">		value := dataNode.getValue()</span><br><span class="line">		<span class="built_in">c</span>.appendSizeAndData([]byte(key))</span><br><span class="line">		<span class="built_in">c</span>.appendSizeAndData(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="appendSizeAndData">appendSizeAndData</h3><p>添加数据和容量<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *bucketHashCalculator)</span></span> appendSizeAndData(b []byte) &#123;</span><br><span class="line">	<span class="built_in">c</span>.appendSize(len(b))</span><br><span class="line">	<span class="built_in">c</span>.hashingData = append(<span class="built_in">c</span>.hashingData, b...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="appendSize">appendSize</h3><p>增加容量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *bucketHashCalculator)</span></span> appendSize(size int) &#123;</span><br><span class="line">	<span class="built_in">c</span>.hashingData = append(<span class="built_in">c</span>.hashingData, proto.<span class="type">EncodeVarint</span>(uint64(size))...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bucket_key">bucket_key</h2><p>bucket key的结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bucketKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	level        <span class="typename">int</span>  <span class="comment">//级别</span></span><br><span class="line">	bucketNumber <span class="typename">int</span>  <span class="comment">//bucket号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newBucketKey">newBucketKey</h3><p>当level为0，bucketNumber为1时，构造bucket树根节点；<br>当level为bucketKey.level-1, bucketNumber为conf.computeParentBucketNumber(bucketKey.bucketNumber)<br>时构建的是父节点的bucketkey<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> newBucketKey(level int, <span class="keyword">bucketNumber </span>int) *<span class="keyword">bucketKey </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> level &gt; conf.getLowestLevel() <span class="title">||</span> level &lt; <span class="number">0</span> &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Invalid Level [%d] for bucket key. Level can be between 0 and [%d]"</span>, level, conf.lowestLevel))</span><br><span class="line">		//如果级别大于最低级别或者级别小于<span class="number">0</span>，则输出当前级别以及最小级别</span><br><span class="line">	&#125;</span><br><span class="line">//如果<span class="keyword">bucket号小于1或者大于bucket级别对应的级别好，则返回bucketkey的级别和级别号</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">bucketNumber </span>&lt; <span class="number">1</span> <span class="title">||</span> <span class="keyword">bucketNumber </span>&gt; conf.getNumBuckets(level) &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Invalid bucket number [%d]. Bucket nuber at level [%d] can be between 1 and [%d]"</span>, <span class="keyword">bucketNumber, </span>level, conf.getNumBuckets(level)))</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;<span class="keyword">bucketKey&#123;level, </span><span class="keyword">bucketNumber&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="getChildIndex">getChildIndex</h3><p>获取子节点的索引<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">bucketKey </span>*<span class="keyword">bucketKey) </span>getChildIndex(childKey *<span class="keyword">bucketKey) </span>int &#123;</span><br><span class="line">	<span class="keyword">bucketNumberOfFirstChild </span>:= ((<span class="keyword">bucketKey.bucketNumber </span>- <span class="number">1</span>) * conf.getMaxGroupingAtEachLevel()) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">bucketNumberOfLastChild </span>:= <span class="keyword">bucketKey.bucketNumber </span>* conf.getMaxGroupingAtEachLevel()</span><br><span class="line">	<span class="preprocessor">if</span> childKey.<span class="keyword">bucketNumber </span>&lt; <span class="keyword">bucketNumberOfFirstChild </span><span class="title">||</span> childKey.<span class="keyword">bucketNumber </span>&gt; <span class="keyword">bucketNumberOfLastChild </span>&#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"[%#v] is not a valid child bucket of [%#v]"</span>, childKey, <span class="keyword">bucketKey))</span><br><span class="line"></span>	&#125;</span><br><span class="line">	return childKey.<span class="keyword">bucketNumber </span>- <span class="keyword">bucketNumberOfFirstChild</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bucket_node">bucket_node</h2><p>bucketnode的结构如下</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">type</span> <span class="keyword">bucketNode </span><span class="keyword">struct </span>&#123;</span><br><span class="line">	<span class="keyword">bucketKey </span>         *<span class="keyword">bucketKey </span></span><br><span class="line">	childrenCryptoHash [][]<span class="keyword">byte </span>//子节点的加密哈希</span><br><span class="line">	childrenUpdated    []<span class="keyword">bool </span> //子节点更新</span><br><span class="line">	<span class="keyword">markedForDeletion </span> <span class="keyword">bool </span> //删除标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unmarshalBucketNode">unmarshalBucketNode</h3><p>重组bucketnode<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func unmarshalBucketNode<span class="list">(<span class="keyword">bucketKey</span> <span class="variable">*bucketKey, serializedBytes []byte) *</span>bucketNode &#123;</span><br><span class="line">	bucketNode <span class="keyword">:=</span> newBucketNode<span class="list">(<span class="keyword">bucketKey</span>)</span></span><br><span class="line">	buffer <span class="keyword">:=</span> proto.NewBuffer<span class="list">(<span class="keyword">serializedBytes</span>)</span></span><br><span class="line">	for i <span class="keyword">:=</span> <span class="number">0</span><span class="comment">; i &lt; conf.getMaxGroupingAtEachLevel(); i++ &#123;</span></span><br><span class="line">		childCryptoHash, err <span class="keyword">:=</span> buffer.DecodeRawBytes<span class="list">(<span class="keyword">false</span>)</span></span><br><span class="line">		if err != <span class="literal">nil</span> &#123;</span><br><span class="line">			panic<span class="list">(<span class="keyword">fmt</span>.Errorf<span class="list">(<span class="string">"this error should not occur: %s"</span>, err)</span>)</span></span><br><span class="line">		&#125;</span><br><span class="line">		if !util.IsNil<span class="list">(<span class="keyword">childCryptoHash</span>)</span> &#123;</span><br><span class="line">			bucketNode.childrenCryptoHash[i] = childCryptoHash</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bucketNode</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="mergeBucketNode">mergeBucketNode</h3><p>合并bucket节点<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">func</span> (<span class="keyword">bucketNode </span>*<span class="keyword">bucketNode) </span>mergeBucketNode(anotherBucketNode *<span class="keyword">bucketNode) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> !<span class="keyword">bucketNode.bucketKey.equals(anotherBucketNode.bucketKey) </span>&#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Nodes with different keys can not be merged. BaseKey=[%#v], MergeKey=[%#v]"</span>, <span class="keyword">bucketNode.bucketKey, </span>anotherBucketNode.<span class="keyword">bucketKey))</span><br><span class="line"></span>	&#125;</span><br><span class="line">	for i, childCryptoHash := range anotherBucketNode.childrenCryptoHash &#123;</span><br><span class="line">		<span class="preprocessor">if</span> !<span class="keyword">bucketNode.childrenUpdated[i] </span>&amp;&amp; util.IsNil(<span class="keyword">bucketNode.childrenCryptoHash[i]) </span>&#123;</span><br><span class="line">			<span class="keyword">bucketNode.childrenCryptoHash[i] </span>= childCryptoHash</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bucket_tree_delta">bucket_tree_delta</h2><p>包含的功能比较少，直接上代码</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">//创建<span class="keyword">bucket树增量</span><br><span class="line"></span><span class="label">func</span> newBucketTreeDelta() *<span class="keyword">bucketTreeDelta </span>&#123;</span><br><span class="line">	return &amp;<span class="keyword">bucketTreeDelta&#123;make(map[int]byBucketNumber)&#125;</span><br><span class="line"></span>&#125;</span><br><span class="line">//获取或者创建<span class="keyword">Bucket节点</span><br><span class="line"></span><span class="label">func</span> (<span class="keyword">bucketTreeDelta </span>*<span class="keyword">bucketTreeDelta) </span>getOrCreateBucketNode(<span class="keyword">bucketKey </span>*<span class="keyword">bucketKey) </span>*<span class="keyword">bucketNode </span>&#123;</span><br><span class="line">	<span class="keyword">byBucketNumber </span>:= <span class="keyword">bucketTreeDelta.byLevel[bucketKey.level]</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">byBucketNumber </span>== nil &#123;</span><br><span class="line">		<span class="keyword">byBucketNumber </span>= make(<span class="preprocessor">map</span>[int]*<span class="keyword">bucketNode)</span><br><span class="line"></span>		<span class="keyword">bucketTreeDelta.byLevel[bucketKey.level] </span>= <span class="keyword">byBucketNumber</span><br><span class="line"></span>	&#125;</span><br><span class="line">	<span class="keyword">bucketNode </span>:= <span class="keyword">byBucketNumber[bucketKey.bucketNumber]</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">bucketNode </span>== nil &#123;</span><br><span class="line">		<span class="keyword">bucketNode </span>= newBucketNode(<span class="keyword">bucketKey)</span><br><span class="line"></span>		<span class="keyword">byBucketNumber[bucketKey.bucketNumber] </span>= <span class="keyword">bucketNode</span><br><span class="line"></span>	&#125;</span><br><span class="line">	return <span class="keyword">bucketNode</span><br><span class="line"></span>&#125;</span><br><span class="line"></span><br><span class="line">//获取某一级别下的<span class="keyword">bucket节点</span><br><span class="line"></span><span class="label">func</span> (<span class="keyword">bucketTreeDelta </span>*<span class="keyword">bucketTreeDelta) </span>getBucketNodesAt(level int) []*<span class="keyword">bucketNode </span>&#123;</span><br><span class="line">	<span class="keyword">bucketNodes </span>:= []*<span class="keyword">bucketNode&#123;&#125;</span><br><span class="line"></span>	<span class="keyword">byBucketNumber </span>:= <span class="keyword">bucketTreeDelta.byLevel[level]</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">byBucketNumber </span>== nil &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	for _, <span class="keyword">bucketNode </span>:= range <span class="keyword">byBucketNumber </span>&#123;</span><br><span class="line">		<span class="keyword">bucketNodes </span>= append(<span class="keyword">bucketNodes, </span><span class="keyword">bucketNode)</span><br><span class="line"></span>	&#125;</span><br><span class="line">	return <span class="keyword">bucketNodes</span><br><span class="line"></span>&#125;</span><br><span class="line">//获取根节点</span><br><span class="line"><span class="label">func</span> (<span class="keyword">bucketTreeDelta </span>*<span class="keyword">bucketTreeDelta) </span>getRootNode() *<span class="keyword">bucketNode </span>&#123;</span><br><span class="line">	<span class="keyword">bucketNodes </span>:= <span class="keyword">bucketTreeDelta.getBucketNodesAt(0)</span><br><span class="line"></span>	<span class="preprocessor">if</span> <span class="keyword">bucketNodes </span>== nil <span class="title">||</span> len(<span class="keyword">bucketNodes) </span>== <span class="number">0</span> &#123;</span><br><span class="line">		panic(<span class="string">"This method should be called after processing is completed (i.e., the root node has been created)"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">bucketNodes[0]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="config">config</h2><p>计算父节点的bucket数量<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (config *config) computeParentBucketNumber(bucketNumber <span class="keyword">int</span>) <span class="keyword">int</span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Computing parent bucket number for bucketNumber [%d]"</span>, bucketNumber)</span><br><span class="line">	parentBucketNumber := bucketNumber / config.getMaxGroupingAtEachLevel()</span><br><span class="line">	<span class="keyword">if</span> bucketNumber%config.getMaxGroupingAtEachLevel() != 0 &#123;</span><br><span class="line">		parentBucketNumber++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parentBucketNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Datakey">Datakey</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建datakey</span></span><br><span class="line">func newDataKey(chaincodeID string, <span class="variable">key</span> string) *dataKey &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Enter - newDataKey. chaincodeID=[%s], key=[%s]"</span>, chaincodeID, <span class="variable">key</span>)</span><br><span class="line">	compositeKey := statemgmt.ConstructCompositeKey(chaincodeID, <span class="variable">key</span>)</span><br><span class="line">	bucketHash := conf.computeBucketHash(compositeKey)</span><br><span class="line">	<span class="comment">// 添加一个，因为 - 我们开始启动bucket的数为1</span></span><br><span class="line">	bucketNumber := <span class="built_in">int</span>(bucketHash)%conf.getNumBucketsAtLowestLevel() + <span class="number">1</span></span><br><span class="line">	dataKey := &amp;dataKey&#123;newBucketKeyAtLowestLevel(bucketNumber), compositeKey&#125;</span><br><span class="line">	logger.Debug(<span class="string">"Exit - newDataKey=[%s]"</span>, dataKey)</span><br><span class="line">	<span class="keyword">return</span> dataKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小化DataKey可能的字节</span></span><br><span class="line">func minimumPossibleDataKeyBytesFor(bucketKey *bucketKey) []<span class="built_in">byte</span> &#123;</span><br><span class="line">	<span class="built_in">min</span> := encodeBucketNumber(bucketKey.bucketNumber)</span><br><span class="line">	<span class="built_in">min</span> = <span class="built_in">append</span>(<span class="built_in">min</span>, <span class="built_in">byte</span>(<span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func minimumPossibleDataKeyBytes(bucketNumber <span class="built_in">int</span>, chaincodeID string, <span class="variable">key</span> string) []<span class="built_in">byte</span> &#123;</span><br><span class="line">	b := encodeBucketNumber(bucketNumber)</span><br><span class="line">	b = <span class="built_in">append</span>(b, statemgmt.ConstructCompositeKey(chaincodeID, <span class="variable">key</span>)...)</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="data_nodes_delta">data_nodes_delta</h2><h3 id="newDataNodesDelta">newDataNodesDelta</h3><p>创建datanode增量<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func newDataNodesDelta<span class="list">(<span class="keyword">stateDelta</span> <span class="variable">*statemgmt.StateDelta) *</span>dataNodesDelta &#123;</span><br><span class="line">	dataNodesDelta <span class="keyword">:=</span> <span class="keyword">&amp;dataNodesDelta</span>&#123;make<span class="list">(<span class="keyword">map</span>[bucketKey]dataNodes)</span>&#125;</span><br><span class="line">	chaincodeIDs <span class="keyword">:=</span> stateDelta.GetUpdatedChaincodeIds<span class="list">(<span class="keyword">false</span>)</span></span><br><span class="line">	for _, chaincodeID <span class="keyword">:=</span> range chaincodeIDs &#123;</span><br><span class="line">		updates <span class="keyword">:=</span> stateDelta.GetUpdates<span class="list">(<span class="keyword">chaincodeID</span>)</span></span><br><span class="line">		for key, updatedValue <span class="keyword">:=</span> range updates &#123;</span><br><span class="line">			if stateDelta.RollBackwards &#123;</span><br><span class="line">				dataNodesDelta.add<span class="list">(<span class="keyword">chaincodeID</span>, key, updatedValue.GetPreviousValue<span class="list">()</span>)</span></span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				dataNodesDelta.add<span class="list">(<span class="keyword">chaincodeID</span>, key, updatedValue.GetValue<span class="list">()</span>)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for _, dataNodes <span class="keyword">:=</span> range dataNodesDelta.byBucket &#123;</span><br><span class="line">		sort.Sort<span class="list">(<span class="keyword">dataNodes</span>)</span></span><br><span class="line">	&#125;</span><br><span class="line">	return dataNodesDelta</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="getAffectedBuckets">getAffectedBuckets</h3><p>获取受到影响的buckets<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">func (dataNodesDelta *dataNodesDelta) <span class="function">getAffectedBuckets</span>() <span class="attr_selector">[]</span>*bucketKey &#123;</span><br><span class="line">	changedBuckets <span class="value">:= []*bucketKey&#123;&#125;</span><br><span class="line">	for bucketKey := range dataNodesDelta.byBucket &#123;</span><br><span class="line">		copyOfBucketKey := bucketKey.<span class="function">clone</span>()</span><br><span class="line">		logger.<span class="function">Debug</span>(<span class="string">"Adding changed bucket [%s]"</span>, copyOfBucketKey)</span><br><span class="line">		changedBuckets = <span class="function">append</span>(changedBuckets, copyOfBucketKey)</span><br><span class="line">	&#125;</span><br><span class="line">	logger.<span class="function">Debug</span>(<span class="string">"Changed buckets are = [%s]"</span>, changedBuckets)</span><br><span class="line">	return changedBuckets</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="range_scan_iterator">range_scan_iterator</h2><p>RangeScanIterator实现了 ‘statemgmt.RangeScanIterator’接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RangeScanIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	dbItr               *gorocksdb.Iterator</span><br><span class="line">	chaincodeID         <span class="typename">string</span></span><br><span class="line">	startKey            <span class="typename">string</span></span><br><span class="line">	endKey              <span class="typename">string</span></span><br><span class="line">	currentBucketNumber <span class="typename">int</span></span><br><span class="line">	currentKey          <span class="typename">string</span></span><br><span class="line">	currentValue        []<span class="typename">byte</span></span><br><span class="line">	done                <span class="typename">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是其中接口实现的一些细节<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (itr *RangeScanIterator) Next() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> itr.done &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> itr.dbItr.Valid() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建键 - 值字节的副本，因为潜在的键值字节由UTR重用。关闭时没有必要为迭代器释放内存而释放切片。</span></span><br><span class="line">		keyBytes := statemgmt.Copy(itr.dbItr.Key().Data())</span><br><span class="line">		valueBytes := statemgmt.Copy(itr.dbItr.Value().Data())</span><br><span class="line"></span><br><span class="line">		dataNode := unmarshalDataNodeFromBytes(keyBytes, valueBytes)</span><br><span class="line">		dataKey := dataNode.dataKey</span><br><span class="line">		chaincodeID, key := statemgmt.DecodeCompositeKey(dataNode.getCompositeKey())</span><br><span class="line">		value := dataNode.value</span><br><span class="line">		logger.Debug(<span class="string">"Evaluating data-key = %s"</span>, dataKey)</span><br><span class="line"></span><br><span class="line">		bucketNumber := dataKey.bucketKey.bucketNumber</span><br><span class="line">		<span class="keyword">if</span> bucketNumber &gt; itr.currentBucketNumber &#123;</span><br><span class="line">			itr.seekForStartKeyWithinBucket(bucketNumber)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> chaincodeID == itr.chaincodeID &amp;&amp; (itr.endKey == <span class="string">""</span> || key &lt;= itr.endKey) &#123;</span><br><span class="line">			logger.Debug(<span class="string">"including data-key = %s"</span>, dataKey)</span><br><span class="line">			itr.currentKey = key</span><br><span class="line">			itr.currentValue = value</span><br><span class="line">			itr.dbItr.Next()</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		itr.seekForStartKeyWithinBucket(bucketNumber + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	itr.done = <span class="keyword">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="snapshot_iterator">snapshot_iterator</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口实现</span></span><br><span class="line">type <span class="type">StateSnapshotIterator</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	dbItr *gorocksdb.<span class="type">Iterator</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建迭代器</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">newStateSnapshotIterator</span><span class="params">(snapshot *gorocksdb.Snapshot)</span></span> (*<span class="type">StateSnapshotIterator</span>, error) &#123;</span><br><span class="line">	dbItr := db.<span class="type">GetDBHandle</span>().<span class="type">GetStateCFSnapshotIterator</span>(snapshot)</span><br><span class="line">	dbItr.<span class="type">Seek</span>([]byte&#123;<span class="number">0x01</span>&#125;)</span><br><span class="line">	dbItr.<span class="type">Prev</span>()</span><br><span class="line">	<span class="keyword">return</span> &amp;<span class="type">StateSnapshotIterator</span>&#123;dbItr&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现细节-Next</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(snapshotItr *StateSnapshotIterator)</span></span> <span class="type">Next</span>() bool &#123;</span><br><span class="line">	snapshotItr.dbItr.<span class="type">Next</span>()</span><br><span class="line">	<span class="keyword">return</span> snapshotItr.dbItr.<span class="type">Valid</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现细节-GetRawKeyValue</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(snapshotItr *StateSnapshotIterator)</span></span> <span class="type">GetRawKeyValue</span>() ([]byte, []byte) &#123;</span><br><span class="line"><span class="comment">//创建键 - 值字节的副本，因为潜在的键值字节由UTR重用。关闭时没有必要为迭代器释放内存而释放切片。</span></span><br><span class="line">	</span><br><span class="line">	keyBytes := statemgmt.<span class="type">Copy</span>(snapshotItr.dbItr.<span class="type">Key</span>().<span class="type">Data</span>())</span><br><span class="line">	valueBytes := statemgmt.<span class="type">Copy</span>(snapshotItr.dbItr.<span class="type">Value</span>().<span class="type">Data</span>())</span><br><span class="line">	dataNode := unmarshalDataNodeFromBytes(keyBytes, valueBytes)</span><br><span class="line">	<span class="keyword">return</span> dataNode.getCompositeKey(), dataNode.getValue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现细节-Close </span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(snapshotItr *StateSnapshotIterator)</span></span> <span class="type">Close</span>() &#123;</span><br><span class="line">	snapshotItr.dbItr.<span class="type">Close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="state_impl">state_impl</h2><p>实现了  ‘statemgmt.HashableState’接口</p>
<h3 id="NewStateImpl">NewStateImpl</h3><p>构建一个新的StateImpl<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStateImpl</span><span class="params">()</span> *<span class="title">StateImpl</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> &amp;StateImpl&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Initialize">Initialize</h3><p>状态初始化<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Impl *StateImpl) Initialize(configs map[string]interface&#123;&#125;) error &#123;</span><br><span class="line">	initConfig(configs)</span><br><span class="line">	rootBucketNode, err := fetchBucketNodeFromDB(constructRootBucketKey())</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	if rootBucketNode != nil &#123;</span><br><span class="line">		<span class="keyword">state</span>Impl.persistedStateHash = rootBucketNode.computeCryptoHash()</span><br><span class="line">		<span class="keyword">state</span>Impl.lastComputedCryptoHash = <span class="keyword">state</span>Impl.persistedStateHash</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">//我们可以创建一个高速缓存，并保持所有的bucket节点预加载。</span><br><span class="line">//因为，铲斗节点不包含实际数据和最大可能的bucket是预先确定的，所述存储器需求</span><br><span class="line">//可能不是非常高，或者可以容易地控制 - 通过保持在高速缓存中选择性bucket（bucket</span><br><span class="line">//树的最可能的前面几级 - 因为，较高的bucket的水平，</span><br><span class="line">//更是将需要散列重新计算的几率）</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PrepareWorkingSet">PrepareWorkingSet</h3><p>准备工作集<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Impl *StateImpl) PrepareWorkingSet(<span class="keyword">state</span>Delta *statemgmt.StateDelta) error &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Enter - PrepareWorkingSet()"</span>)</span><br><span class="line">	if <span class="keyword">state</span>Delta.IsEmpty() &#123;</span><br><span class="line">		logger.Debug(<span class="string">"Ignoring working-set as it is empty"</span>)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>Impl.dataNodesDelta = newDataNodesDelta(<span class="keyword">state</span>Delta)</span><br><span class="line">	<span class="keyword">state</span>Impl.bucketTreeDelta = newBucketTreeDelta()</span><br><span class="line">	<span class="keyword">state</span>Impl.recomputeCryptoHash = true</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="computeDataNodesCryptoHash">computeDataNodesCryptoHash</h3><p>计算datanodes的哈希加密计算<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> computeDataNodesCryptoHash(bucketKey *bucketKey, updatedNodes dataNodes, existingNodes dataNodes) []<span class="typename">byte</span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Computing crypto-hash for bucket [%s]. numUpdatedNodes=[%d], numExistingNodes=[%d]"</span>, bucketKey, <span class="built_in">len</span>(updatedNodes), <span class="built_in">len</span>(existingNodes))</span><br><span class="line">	bucketHashCalculator := newBucketHashCalculator(bucketKey)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(updatedNodes) &amp;&amp; j &lt; <span class="built_in">len</span>(existingNodes) &#123;</span><br><span class="line">		updatedNode := updatedNodes[i]</span><br><span class="line">		existingNode := existingNodes[j]</span><br><span class="line">		c := bytes.Compare(updatedNode.dataKey.compositeKey, existingNode.dataKey.compositeKey)</span><br><span class="line">		<span class="keyword">var</span> nextNode *dataNode</span><br><span class="line">		<span class="keyword">switch</span> c &#123;</span><br><span class="line">		<span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">			nextNode = updatedNode</span><br><span class="line">			i++</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			nextNode = updatedNode</span><br><span class="line">			i++</span><br><span class="line">			j++</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			nextNode = existingNode</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !nextNode.isDelete() &#123;</span><br><span class="line">			bucketHashCalculator.addNextNode(nextNode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> remainingNodes dataNodes</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(updatedNodes) &#123;</span><br><span class="line">		remainingNodes = updatedNodes[i:]</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(existingNodes) &#123;</span><br><span class="line">		remainingNodes = existingNodes[j:]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, remainingNode := <span class="keyword">range</span> remainingNodes &#123;</span><br><span class="line">		<span class="keyword">if</span> !remainingNode.isDelete() &#123;</span><br><span class="line">			bucketHashCalculator.addNextNode(remainingNode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bucketHashCalculator.computeCryptoHash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="state">state</h1><h2 id="composite_range_scan_iterator">composite_range_scan_iterator</h2><p>包装了一个以上的潜在迭代，下面是具体实施，从第一底层迭代器开始，<br> 耗尽第一底层迭代后，移动到第二个潜在的迭代器。实施重复这个直到已经耗尽之前的底层迭代器此外，如果键值是找到从底层迭代器的键值被跳过任一前代的迭代器</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(itr *CompositeRangeScanIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span> &#123;</span></span><br><span class="line">	currentItrNumber := itr.currentItrNumber</span><br><span class="line">	currentItr := itr.itrs[currentItrNumber]</span><br><span class="line">	logger.Debug(<span class="string">"Operating on iterator number = %d"</span>, currentItrNumber)</span><br><span class="line">	keyAvailable := currentItr.<span class="keyword">Next</span>()</span><br><span class="line">	<span class="keyword">for</span> keyAvailable &#123;</span><br><span class="line">		key, _ := currentItr.GetKeyValue()</span><br><span class="line">		logger.Debug(<span class="string">"Retrieved key = %s"</span>, key)</span><br><span class="line">		skipKey := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> i := currentItrNumber - <span class="number">1</span><span class="comment">; i &gt;= 0; i-- &#123;</span></span><br><span class="line">			logger.Debug(<span class="string">"Evaluating key = %s in itr number = %d. currentItrNumber = %d"</span>, key, i, currentItrNumber)</span><br><span class="line">			previousItr := itr.itrs[i]</span><br><span class="line">			<span class="keyword">if</span> previousItr.(*statemgmt.StateDeltaIterator).ContainsKey(key) &#123;</span><br><span class="line">				skipKey = <span class="literal">true</span></span><br><span class="line">				<span class="built_in">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> skipKey &#123;</span><br><span class="line">			logger.Debug(<span class="string">"Skipping key = %s"</span>, key)</span><br><span class="line">			keyAvailable = currentItr.<span class="keyword">Next</span>()</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> keyAvailable || currentItrNumber == <span class="number">2</span> &#123;</span><br><span class="line">		logger.Debug(<span class="string">"Returning for current key"</span>)</span><br><span class="line">		<span class="keyword">return</span> keyAvailable</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debug(<span class="string">"Moving to next iterator"</span>)</span><br><span class="line">	itr.currentItrNumber++</span><br><span class="line">	<span class="keyword">return</span> itr.<span class="keyword">Next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="state_snapshot">state_snapshot</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按实际的实施和数据库快照封装了对状态快照的迭代</span></span><br><span class="line">type <span class="type">StateSnapshot</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	blockNumber  uint64</span><br><span class="line">	stateImplItr statemgmt.<span class="type">StateSnapshotIterator</span></span><br><span class="line">	dbSnapshot   *gorocksdb.<span class="type">Snapshot</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建当前块全局状态的新快照</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">newStateSnapshot</span><span class="params">(blockNumber uint64, dbSnapshot *gorocksdb.Snapshot)</span></span> (*<span class="type">StateSnapshot</span>, error) &#123;</span><br><span class="line">	itr, err := stateImpl.<span class="type">GetStateSnapshotIterator</span>(dbSnapshot)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	snapshot := &amp;<span class="type">StateSnapshot</span>&#123;blockNumber, itr, dbSnapshot&#125;</span><br><span class="line">	<span class="keyword">return</span> snapshot, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当您使用这个资源做这必须调用释放快照</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ss *StateSnapshot)</span></span> <span class="type">Release</span>() &#123;</span><br><span class="line">	ss.stateImplItr.<span class="type">Close</span>()</span><br><span class="line">	ss.dbSnapshot.<span class="type">Release</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来将迭代器移动到下一个键/值对的状态</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ss *StateSnapshot)</span></span> <span class="type">Next</span>() bool &#123;</span><br><span class="line">	<span class="keyword">return</span> ss.stateImplItr.<span class="type">Next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回在当前迭代器位置的键和值的原始字节</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ss *StateSnapshot)</span></span> <span class="type">GetRawKeyValue</span>() ([]byte, []byte) &#123;</span><br><span class="line">	<span class="keyword">return</span> ss.stateImplItr.<span class="type">GetRawKeyValue</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与此全局状态的快照相关联的块号</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(ss *StateSnapshot)</span></span> <span class="type">GetBlockNumber</span>() uint64 &#123;</span><br><span class="line">	<span class="keyword">return</span> ss.blockNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="state-1">state</h2><p>构造全局状态，封装状态持久性的特定管理实现，它不是线程安全的</p>
<h3 id="NewState">NewState</h3><p>构造一个新的状态。对初始化状态的实现进行封装<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func NewState() *State &#123;</span><br><span class="line">	<span class="keyword">state</span>ImplName := viper.GetString(<span class="string">"ledger.state.dataStructure.name"</span>)</span><br><span class="line">	<span class="keyword">state</span>ImplConfigs := viper.GetStringMap(<span class="string">"ledger.state.dataStructure.configs"</span>)</span><br><span class="line"></span><br><span class="line">	if len(<span class="keyword">state</span>ImplName) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">state</span>ImplName = detaultStateImpl</span><br><span class="line">		<span class="keyword">state</span>ImplConfigs = nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch <span class="keyword">state</span>ImplName &#123;</span><br><span class="line">	case <span class="string">"buckettree"</span>:</span><br><span class="line">		<span class="keyword">state</span>Impl = buckettree.NewStateImpl()</span><br><span class="line">	case <span class="string">"trie"</span>:</span><br><span class="line">		<span class="keyword">state</span>Impl = trie.NewStateTrie()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Error during initialization of state implementation. State data structure '%s' is not valid."</span>, <span class="keyword">state</span>ImplName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := <span class="keyword">state</span>Impl.Initialize(<span class="keyword">state</span>ImplConfigs)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Error during initialization of state implementation: %s"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	deltaHistorySize := viper.GetInt(<span class="string">"ledger.state.deltaHistorySize"</span>)</span><br><span class="line">	if deltaHistorySize <span class="variable">&lt; 0 &#123;</span><br><span class="line">		panic(fmt.Errorf("Delta history size must be greater than or equal to 0. Current value is %d.", deltaHistorySize))</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;State&#123;stateImpl, statemgmt.NewStateDelta(), statemgmt.NewStateDelta(), "", make(map[string][]byte),</span><br><span class="line">		false, uint64(deltaHistorySize)&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="TxBegin-1">TxBegin</h3><p>标记开始新的tx。如果tx已在进行中，将调用混乱<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span> *State) TxBegin(txUUID string) &#123;</span><br><span class="line">	logger.Debug(<span class="string">"txBegin() for txUuid [%s]"</span>, txUUID)</span><br><span class="line">	if <span class="keyword">state</span>.txInProgress() &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"A tx [%s] is already in progress. Received call for begin of another tx [%s]"</span>, <span class="keyword">state</span>.currentTxUUID, txUUID))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>.currentTxUUID = txUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Get">Get</h3><p>返回chaincodeID和键的状态。如果提交为false，首先从内存中查找，如果缺失，从数据库获取。如果为true，仅仅可以从数据库中获取。<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span> *State) Get(chaincodeID string, key string, committed bool) ([]byte, error) &#123;</span><br><span class="line">	if !committed &#123;</span><br><span class="line">		valueHolder := <span class="keyword">state</span>.currentTxStateDelta.Get(chaincodeID, key)</span><br><span class="line">		if valueHolder != nil &#123;</span><br><span class="line">			return valueHolder.GetValue(), nil</span><br><span class="line">		&#125;</span><br><span class="line">		valueHolder = <span class="keyword">state</span>.<span class="keyword">state</span>Delta.Get(chaincodeID, key)</span><br><span class="line">		if valueHolder != nil &#123;</span><br><span class="line">			return valueHolder.GetValue(), nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">state</span>.<span class="keyword">state</span>Impl.Get(chaincodeID, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GetRangeScanIterator">GetRangeScanIterator</h3><p>返回一来获取所有startKey和endKey之间的键（和值）的迭代器<br>对于chaincodeID（假设按照键的词汇顺序）。<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span> *State) GetRangeScanIterator(chaincodeID string, startKey string, endKey string, committed bool) (statemgmt.RangeScanIterator, error) &#123;</span><br><span class="line">	<span class="keyword">state</span>ImplItr, err := <span class="keyword">state</span>.<span class="keyword">state</span>Impl.GetRangeScanIterator(chaincodeID, startKey, endKey)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if committed &#123;</span><br><span class="line">		return <span class="keyword">state</span>ImplItr, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return newCompositeRangeScanIterator(</span><br><span class="line">		statemgmt.NewStateDeltaRangeScanIterator(<span class="keyword">state</span>.currentTxStateDelta, chaincodeID, startKey, endKey),</span><br><span class="line">		statemgmt.NewStateDeltaRangeScanIterator(<span class="keyword">state</span>.<span class="keyword">state</span>Delta, chaincodeID, startKey, endKey),</span><br><span class="line">		<span class="keyword">state</span>ImplItr), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GetHash">GetHash</h3><p>如果计算要应用的状态增量如果是新状态的哈希值。<br>如果stateDelta已最近一次调用后，想要更改此功能只能重新计算<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span> *State) GetHash() ([]byte, error) &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Enter - GetHash()"</span>)</span><br><span class="line">	if <span class="keyword">state</span>.updateStateImpl &#123;</span><br><span class="line">		logger.Debug(<span class="string">"updating stateImpl with working-set"</span>)</span><br><span class="line">		<span class="keyword">state</span>.<span class="keyword">state</span>Impl.PrepareWorkingSet(<span class="keyword">state</span>.<span class="keyword">state</span>Delta)</span><br><span class="line">		<span class="keyword">state</span>.updateStateImpl = false</span><br><span class="line">	&#125;</span><br><span class="line">	hash, err := <span class="keyword">state</span>.<span class="keyword">state</span>Impl.ComputeCryptoHash()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Debug(<span class="string">"Exit - GetHash()"</span>)</span><br><span class="line">	return hash, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="trie">trie</h1><p>trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。</p>
<h2 id="TrieKey">TrieKey</h2><p>如下是trie key的接口定义<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">type trieKeyInterface <span class="class"><span class="keyword">interface</span> </span>&#123;</span><br><span class="line">	getLevel() <span class="keyword">int</span> <span class="comment">//获取级别</span></span><br><span class="line">	getParentTrieKey() trieKeyInterface <span class="comment">//获取父 trie key</span></span><br><span class="line">	getIndexInParent() <span class="keyword">int</span>  <span class="comment">//获取索引</span></span><br><span class="line">	getEncodedBytes() []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newTrieKey">newTrieKey</h3><p>创建一个trie key<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">func</span> <span class="tag">newTrieKey</span>(<span class="tag">chaincodeID</span> <span class="tag">string</span>, <span class="tag">key</span> <span class="tag">string</span>) *<span class="tag">trieKey</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">compositeKey </span>:<span class="value">= statemgmt.<span class="function">ConstructCompositeKey</span>(chaincodeID, key)</span><br><span class="line">	return <span class="function">newTrieKeyFromCompositeKey</span>(compositeKey)</span><br><span class="line"></span></span></span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newTrieKeyFromCompositeKey">newTrieKeyFromCompositeKey</h3><p>从组合键中创建trie key<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTrieKeyFromCompositeKey</span><span class="params">(compositeKey []byte)</span> *<span class="title">trieKey</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> &amp;trieKey&#123;trieKeyEncoderImpl.newTrieKey(compositeKey)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="getIndexInParent">getIndexInParent</h3><p>获取父triekey的索引<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(key *trieKey)</span> <span class="title">getIndexInParent</span><span class="params">()</span> <span class="title">int</span> &#123;</span></span><br><span class="line">	<span class="keyword">if</span> key.isRootKey() &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Parent for Trie root shoould not be asked for"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key.trieKeyImpl.getIndexInParent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="getParentTrieKey">getParentTrieKey</h3><p>获取父 trie key<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func <span class="list">(<span class="keyword">key</span> <span class="variable">*trieKey) getParentTrieKey() *</span>trieKey &#123;</span><br><span class="line">	if key.isRootKey<span class="list">()</span> &#123;</span><br><span class="line">		panic<span class="list">(<span class="keyword">fmt</span>.Errorf<span class="list">(<span class="string">"Parent for Trie root shoould not be asked for"</span>)</span>)</span></span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">&amp;trieKey</span>&#123;key.trieKeyImpl.getParentTrieKey<span class="list">()</span>&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="getEncodedBytes">getEncodedBytes</h3><p>获得字节编码，如果字节编码为0，代表为根的键值<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">func (<span class="variable">key</span> *trieKey) getEncodedBytes() []<span class="built_in">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">key</span>.trieKeyImpl.getEncodedBytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="assertIsChildOf">assertIsChildOf</h3><p>断言是否为孩子节点的trie key<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(key *trieKey)</span> <span class="title">assertIsChildOf</span><span class="params">(parentTrieKey *trieKey)</span> &#123;</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(key.getParentTrieKey().getEncodedBytes(), parentTrieKey.getEncodedBytes()) &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"trie key [%s] is not a child of trie key [%s]"</span>, key, parentTrieKey))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="trie_node">trie_node</h2><p>trienode的结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> trieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	trieKey              *trieKey</span><br><span class="line">	value                []<span class="typename">byte</span> <span class="comment">//值</span></span><br><span class="line">	childrenCryptoHashes <span class="keyword">map</span>[<span class="typename">int</span>][]<span class="typename">byte</span><span class="comment">//孩子节点的哈希加密，key为int，value为byte</span></span><br><span class="line"></span><br><span class="line">	valueUpdated                <span class="typename">bool</span> <span class="comment">//值是否更新</span></span><br><span class="line">	childrenCryptoHashesUpdated <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">bool</span><span class="comment">//是否产生新的哈希加密</span></span><br><span class="line">	markedForDeletion           <span class="typename">bool</span> <span class="comment">//节店删除状态标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setChildCryptoHash">setChildCryptoHash</h3><p>设置孩子节点加密哈希<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">func (trieNode *trieNode) setChildCryptoHash(<span class="keyword">index</span> <span class="keyword">int</span>, childCryptoHash []<span class="keyword">byte</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">index</span> &gt;= trieKeyEncoderImpl.getMaxTrieWidth() &#123;</span><br><span class="line">		panic(fmt.Errorf(<span class="string">"Index for child crypto-hash cannot be greater than [%d]. Tried to access index value [%d]"</span>, trieKeyEncoderImpl.getMaxTrieWidth(), <span class="keyword">index</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> childCryptoHash != nil &#123;</span><br><span class="line">		trieNode.childrenCryptoHashes[<span class="keyword">index</span>] = childCryptoHash</span><br><span class="line">	&#125;</span><br><span class="line">	trieNode.childrenCryptoHashesUpdated[<span class="keyword">index</span>] = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="mergeMissingAttributesFrom">mergeMissingAttributesFrom</h3><p>合并丢失属性<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (trieNode *trieNode) mergeMissingAttributesFrom(dbTrieNode *trieNode) &#123;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Enter mergeMissingAttributesFrom() baseNode=[%s], mergeNode=[%s]"</span>, trieNode, dbTrieNode)</span><br><span class="line">	if !trieNode.valueUpdated &#123;</span><br><span class="line">		trieNode.value = dbTrieNode.value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := range dbTrieNode.childrenCryptoHashes &#123;</span><br><span class="line">		if !trieNode.childrenCryptoHashesUpdated[k] &#123;</span><br><span class="line">			trieNode.childrenCryptoHashes[k] = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Exit mergeMissingAttributesFrom() mergedNode=[%s]"</span>, trieNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="computeCryptoHash-1">computeCryptoHash</h3><p>哈希加密计算<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (trieNode *trieNode) computeCryptoHash() []byte &#123;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Enter computeCryptoHash() for trieNode [%s]"</span>, trieNode)</span><br><span class="line">	var cryptoHashContent []byte</span><br><span class="line">	if trieNode.containsValue() &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Adding value to hash computation for trieNode [%s]"</span>, trieNode)</span><br><span class="line">		key := trieNode.trieKey.getEncodedBytes()</span><br><span class="line">		cryptoHashContent = append(cryptoHashContent, <span class="keyword">proto</span>.EncodeVarint(uint64(len(key)))...)</span><br><span class="line">		cryptoHashContent = append(cryptoHashContent, key...)</span><br><span class="line">		cryptoHashContent = append(cryptoHashContent, trieNode.value...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sortedChildrenIndexes := trieNode.getSortedChildrenIndex()</span><br><span class="line">	<span class="keyword">for</span> _, index := range sortedChildrenIndexes &#123;</span><br><span class="line">		childCryptoHash := trieNode.childrenCryptoHashes[index]</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Adding hash [%#v] for child number [%d] to hash computation for trieNode [%s]"</span>, childCryptoHash, index, trieNode)</span><br><span class="line">		cryptoHashContent = append(cryptoHashContent, childCryptoHash...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if cryptoHashContent == nil &#123;</span><br><span class="line">		// 节点没有关联值，也没有关联孩子节点。</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Returning nil as hash for trieNode = [%s]. Also, marking this key for deletion."</span>, trieNode)</span><br><span class="line">		trieNode.markedForDeletion = true</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if !trieNode.containsValue() &amp;&amp; trieNode.getNumChildren() == <span class="number">1</span> &#123;</span><br><span class="line">		// 节点没有关联值，并且只有一个孩子节点，传递的孩子hash丢失</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Returning hash as of a single child for trieKey = [%s]"</span>, trieNode.trieKey)</span><br><span class="line">		return cryptoHashContent</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Recomputing hash for trieKey = [%s]"</span>, trieNode)</span><br><span class="line">	return util.ComputeCryptoHash(cryptoHashContent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="marshal">marshal</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (trieNode *trieNode) marshal() ([]<span class="typename">byte</span>, error) &#123;</span><br><span class="line">	buffer := proto.NewBuffer([]<span class="typename">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入值</span></span><br><span class="line">	err := buffer.EncodeRawBytes(trieNode.value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	numCryptoHashes := trieNode.getNumChildren()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写加密哈希数</span></span><br><span class="line">	err = buffer.EncodeVarint(<span class="typename">uint64</span>(numCryptoHashes))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> numCryptoHashes == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> buffer.Bytes(), <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, cryptoHash := <span class="keyword">range</span> trieNode.childrenCryptoHashes &#123;</span><br><span class="line">		<span class="comment">//写入加密哈希索引</span></span><br><span class="line">		err = buffer.EncodeVarint(<span class="typename">uint64</span>(i))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写入加密哈希</span></span><br><span class="line">		err = buffer.EncodeRawBytes(cryptoHash)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer.Bytes(), <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getSortedChildrenIndex">getSortedChildrenIndex</h3><p>获得孩子节点排序后的索引<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">func (trieNode *trieNode) getSortedChildrenIndex() []<span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="keyword">keys</span> := make([]<span class="keyword">int</span>, trieNode.getNumChildren())</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := range trieNode.childrenCryptoHashes &#123;</span><br><span class="line">		<span class="keyword">keys</span>[i] = k</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">sort</span>.Ints(<span class="keyword">keys</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">keys</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newTrieDelta">newTrieDelta</h3><p>创建trie的增量<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func newTrieDelta(<span class="keyword">state</span>Delta *statemgmt.StateDelta) *trieDelta &#123;</span><br><span class="line">	trieDelta := &amp;trieDelta&#123;<span class="number">0</span>, make(map[int]levelDeltaMap)&#125;</span><br><span class="line">	chaincodes := <span class="keyword">state</span>Delta.GetUpdatedChaincodeIds(false)</span><br><span class="line">	<span class="keyword">for</span> _, chaincodeID := range chaincodes &#123;</span><br><span class="line">		updates := <span class="keyword">state</span>Delta.GetUpdates(chaincodeID)</span><br><span class="line">		<span class="keyword">for</span> key, updatedvalue := range updates &#123;</span><br><span class="line">			if updatedvalue.IsDelete() &#123;</span><br><span class="line">				trieDelta.delete(chaincodeID, key)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if <span class="keyword">state</span>Delta.RollBackwards &#123;</span><br><span class="line">					trieDelta.<span class="built_in">set</span>(chaincodeID, key, updatedvalue.GetPreviousValue())</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					trieDelta.<span class="built_in">set</span>(chaincodeID, key, updatedvalue.GetValue())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return trieDelta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="trie_db_helper">trie_db_helper</h2><p>从数据库中获取trie节点<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func fetchTrieNodeFromDB(key *trieKey) (*trieNode, error) &#123;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Enter fetchTrieNodeFromDB() for trieKey [%s]"</span>, key)</span><br><span class="line">	openchainDB := db.GetDBHandle()</span><br><span class="line">	trieNodeBytes, err := openchainDB.GetFromStateCF(key.getEncodedBytes())</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Error(<span class="string">"Error in retrieving trie node from DB for triekey [%s]. Error:%s"</span>, key, err)</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if trieNodeBytes == nil &#123;</span><br><span class="line">		return nil, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trieNode, err := unmarshalTrieNode(key, trieNodeBytes)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Error(<span class="string">"Error in unmarshalling trie node for triekey [%s]. Error:%s"</span>, key, err)</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Exit fetchTrieNodeFromDB() for trieKey [%s]"</span>, key)</span><br><span class="line">	return trieNode, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="byteTrieKey">byteTrieKey</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (encoder *byteTrieKeyEncoder) newTrieKey(originalBytes []<span class="typename">byte</span>) trieKeyInterface &#123;</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(originalBytes)</span><br><span class="line">	remainingBytes := <span class="built_in">len</span> % numBytesAtEachLevel</span><br><span class="line">	<span class="comment">//剩余字节=长度和每一个级别字节数的余数</span></span><br><span class="line">	bytesToAppend := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> remainingBytes != <span class="number">0</span> &#123;</span><br><span class="line">		bytesToAppend = numBytesAtEachLevel - remainingBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bytesToAppend; i++ &#123;</span><br><span class="line">		originalBytes = <span class="built_in">append</span>(originalBytes, <span class="typename">byte</span>(<span class="number">0</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> byteTrieKey(originalBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hexTrieKey">hexTrieKey</h2><p>首先定义一个对于索引的映射，类十余bytetriekey，实现了 trieKeyInterface接口<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var charIndexMap = <span class="built_in">map</span>[hexTrieKey]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"0"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="string">"1"</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="string">"2"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">"3"</span>: <span class="number">3</span>,</span><br><span class="line">	<span class="string">"4"</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">"5"</span>: <span class="number">5</span>,</span><br><span class="line">	<span class="string">"6"</span>: <span class="number">6</span>,</span><br><span class="line">	<span class="string">"7"</span>: <span class="number">7</span>,</span><br><span class="line">	<span class="string">"8"</span>: <span class="number">8</span>,</span><br><span class="line">	<span class="string">"9"</span>: <span class="number">9</span>,</span><br><span class="line">	<span class="string">"a"</span>: <span class="number">10</span>,</span><br><span class="line">	<span class="string">"b"</span>: <span class="number">11</span>,</span><br><span class="line">	<span class="string">"c"</span>: <span class="number">12</span>,</span><br><span class="line">	<span class="string">"d"</span>: <span class="number">13</span>,</span><br><span class="line">	<span class="string">"e"</span>: <span class="number">14</span>,</span><br><span class="line">	<span class="string">"f"</span>: <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (encoder *hexTrieKeyEncoder) newTrieKey(originalBytes []byte) trieKeyInterface &#123;</span><br><span class="line">	<span class="keyword">return</span> hexTrieKey(hex.EncodeToString(originalBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="range_scan_iterator-1">range_scan_iterator</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (itr *RangeScanIterator) Next() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> itr.done &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ; itr.dbItr.Valid(); itr.dbItr.Next() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使得键 - 值字节的副本，以至于使得潜在的键值字节由ITR重用。</span></span><br><span class="line">		<span class="comment">//关闭时没有必要为迭代器释放内存释放切片。</span></span><br><span class="line">		trieKeyBytes := statemgmt.Copy(itr.dbItr.Key().Data())</span><br><span class="line">		trieNodeBytes := statemgmt.Copy(itr.dbItr.Value().Data())</span><br><span class="line">		value := unmarshalTrieNodeValue(trieNodeBytes)</span><br><span class="line">		<span class="keyword">if</span> util.IsNil(value) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到一个实际的键值</span></span><br><span class="line">		currentCompositeKey := trieKeyEncoderImpl.decodeTrieKeyBytes(statemgmt.Copy(trieKeyBytes))</span><br><span class="line">		currentChaincodeID, currentKey := statemgmt.DecodeCompositeKey(currentCompositeKey)</span><br><span class="line">		<span class="keyword">if</span> currentChaincodeID == itr.chaincodeID &amp;&amp; (itr.endKey == <span class="string">""</span> || currentKey &lt;= itr.endKey) &#123;</span><br><span class="line">			itr.currentKey = currentKey</span><br><span class="line">			itr.currentValue = value</span><br><span class="line">			itr.dbItr.Next()</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检索指定的范围内的所有的密钥</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	itr.done = <span class="keyword">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="snapshot_iterator-1">snapshot_iterator</h2><p>和range_scan_iterator的实现方式类似<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">func (snapshotItr *StateSnapshotIterator) Next() bool &#123;</span><br><span class="line">	var available bool</span><br><span class="line">	<span class="keyword">for</span> ; snapshotItr.dbItr.Valid(); snapshotItr.dbItr.Next() &#123;</span><br><span class="line"></span><br><span class="line">		trieKeyBytes := statemgmt.Copy(snapshotItr.dbItr.Key().Data())</span><br><span class="line">		trieNodeBytes := statemgmt.Copy(snapshotItr.dbItr.Value().Data())</span><br><span class="line">		value := unmarshalTrieNodeValue(trieNodeBytes)</span><br><span class="line">		<span class="keyword">if</span> util.NotNil(value) &#123;</span><br><span class="line">			snapshotItr.currentKey = trieKeyEncoderImpl.decodeTrieKeyBytes(statemgmt.Copy(trieKeyBytes))</span><br><span class="line">			snapshotItr.currentValue = value</span><br><span class="line">			available = <span class="keyword">true</span></span><br><span class="line">			snapshotItr.dbItr.Next()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> available</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="state_trie">state_trie</h2><p>结构如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateTrie <span class="keyword">struct</span> &#123;</span><br><span class="line">	trieDelta              *trieDelta</span><br><span class="line">	persistedStateHash     []<span class="typename">byte</span> 持久化状态哈希</span><br><span class="line">	lastComputedCryptoHash []<span class="typename">byte</span>  最后哈希加密计算</span><br><span class="line">	recomputeCryptoHash    <span class="typename">bool</span> 重新哈希加密计算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="processChangedNode">processChangedNode</h3><p>节点改变流程<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Trie *StateTrie) processChangedNode(changedNode *trieNode) error &#123;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Enter - processChangedNode() for node [%s]"</span>, changedNode)</span><br><span class="line">	dbNode, err := fetchTrieNodeFromDB(changedNode.trieKey)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	if dbNode != nil &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"processChangedNode() - merging attributes from db node [%s]"</span>, dbNode)</span><br><span class="line">		changedNode.mergeMissingAttributesFrom(dbNode)</span><br><span class="line">	&#125;</span><br><span class="line">	newCryptoHash := changedNode.computeCryptoHash()</span><br><span class="line">	parentNode := <span class="keyword">state</span>Trie.trieDelta.getParentOf(changedNode)</span><br><span class="line">	if parentNode == nil &#123;</span><br><span class="line">		parentNode = newTrieNode(changedNode.getParentTrieKey(), nil, false)</span><br><span class="line">		<span class="keyword">state</span>Trie.trieDelta.addTrieNode(parentNode)</span><br><span class="line">	&#125;</span><br><span class="line">	parentNode.<span class="built_in">set</span>ChildCryptoHash(changedNode.getIndexInParent(), newCryptoHash)</span><br><span class="line">	if <span class="keyword">log</span>HashOfEveryNode &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Hash for changedNode[%s]"</span>, changedNode)</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"%#v"</span>, newCryptoHash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Exit - processChangedNode() for node [%s]"</span>, changedNode)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AddChangesForPersistence">AddChangesForPersistence</h3><p>为持久化添加更改<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Trie *StateTrie) AddChangesForPersistence(writeBatch *gorocksdb.WriteBatch) error &#123;</span><br><span class="line">	if <span class="keyword">state</span>Trie.recomputeCryptoHash &#123;</span><br><span class="line">		_, err := <span class="keyword">state</span>Trie.ComputeCryptoHash()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if <span class="keyword">state</span>Trie.trieDelta == nil &#123;</span><br><span class="line">		<span class="keyword">state</span>TrieLogger.Info(<span class="string">"trieDelta is nil. Not writing anything to DB"</span>)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	openchainDB := db.GetDBHandle()</span><br><span class="line">	lowestLevel := <span class="keyword">state</span>Trie.trieDelta.getLowestLevel()</span><br><span class="line">	<span class="keyword">for</span> level := lowestLevel; level &gt;= <span class="number">0</span>; level-- &#123;</span><br><span class="line">		changedNodes := <span class="keyword">state</span>Trie.trieDelta.deltaMap[level]</span><br><span class="line">		<span class="keyword">for</span> _, changedNode := range changedNodes &#123;</span><br><span class="line">			if changedNode.markedForDeletion &#123;</span><br><span class="line">				writeBatch.DeleteCF(openchainDB.StateCF, changedNode.trieKey.getEncodedBytes())</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			serializedContent, err := changedNode.marshal()</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return err</span><br><span class="line">			&#125;</span><br><span class="line">			writeBatch.PutCF(openchainDB.StateCF, changedNode.trieKey.getEncodedBytes(), serializedContent)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">state</span>TrieLogger.Debug(<span class="string">"Added changes to DB"</span>)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="commons">commons</h1><p>commons位于statemgmt目录下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建复合键，并返回唯一代表一个指定的chaincodeID和 []byte字节。</span></span><br><span class="line"><span class="comment">//这假定chaincodeID不包含0×00字节</span></span><br><span class="line"><span class="comment">//但键值的可以强制实施的限制chaincodeID或使用长度前缀，而不是这里的分隔符</span></span><br><span class="line"><span class="keyword">func</span> ConstructCompositeKey(chaincodeID <span class="typename">string</span>, key <span class="typename">string</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.Join([][]<span class="typename">byte</span>&#123;[]<span class="typename">byte</span>(chaincodeID), []<span class="typename">byte</span>(key)&#125;, stateKeyDelimiter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过解码构建了compositeKey构造复合键的方法，返回原始chaincodeID和键形式</span></span><br><span class="line"><span class="keyword">func</span> DecodeCompositeKey(compositeKey []<span class="typename">byte</span>) (<span class="typename">string</span>, <span class="typename">string</span>) &#123;</span><br><span class="line">	split := bytes.SplitN(compositeKey, stateKeyDelimiter, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="typename">string</span>(split[<span class="number">0</span>]), <span class="typename">string</span>(split[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定字节的副本</span></span><br><span class="line"><span class="keyword">func</span> Copy(src []<span class="typename">byte</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	dest := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	<span class="built_in">copy</span>(dest, src)</span><br><span class="line">	<span class="keyword">return</span> dest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashable_state">hashable_state</h2><p>由stat实现不同的状态管理来实现接口，可以高效地为不同的工作负载条件下，计算加密哈希状态。<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">type HashableState interface &#123;</span><br><span class="line"></span><br><span class="line">	//提供了一个机会来初始化。例如， 可以加载数据库的一些数据来实现<span class="keyword">state</span></span><br><span class="line">	Initialize(configs map[string]interface&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">	// 从数据库获取值</span><br><span class="line">	Get(chaincodeID string, key string) ([]byte, error)</span><br><span class="line"></span><br><span class="line">	// 需要施加到状态，通过捕获需要的变化的<span class="keyword">state</span>Delta</span><br><span class="line">	PrepareWorkingSet(<span class="keyword">state</span>Delta *StateDelta) error</span><br><span class="line"></span><br><span class="line">	//计算状态加密哈希来实现<span class="keyword">state</span>假设状态增量适用以PrepareWorkingSet方法传递</span><br><span class="line">	ComputeCryptoHash() ([]byte, error)</span><br><span class="line"></span><br><span class="line">	//添加的所有键值对，它需要为数据库持续触发statedelta（在、、//PrepareWorkingSet方法传递）。</span><br><span class="line">//除了在StateDelta中的信息，实现还可能希望</span><br><span class="line">//更快进行持久化中间结果的加密哈希计算</span><br><span class="line">	AddChangesForPersistence(writeBatch *gorocksdb.WriteBatch) error</span><br><span class="line"></span><br><span class="line">	// ClearWorkingSet可能会清除<span class="keyword">state</span>实现，它可能已经建立了计算哈希加密和持续变化的状态增量的数据结构</span><br><span class="line">	ClearWorkingSet(changesPersisted bool)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GetStateSnapshotIterator(snapshot *gorocksdb.Snapshot) (StateSnapshotIterator, error)</span><br><span class="line"></span><br><span class="line">	//提供一种应该给一个给定的chaincodeID使得返回键应该词法更大//所有键值迭代大于或等于startKey且小于或等于endKey。如果startKey参//数的值是假设一个空字符串startKey是在DB的chaincodeID可用最小的关//键。同样，对于endKey参数为空字符串假定endKey可用的分贝为chaincodeID//的最大键</span><br><span class="line">	GetRangeScanIterator(chaincodeID string, startKey string, endKey string) (RangeScanIterator, error)</span><br><span class="line"></span><br><span class="line">	//与StateDelta之前一些提示制备和PrepareWorkingSet方法通//过提供了可能。一个<span class="keyword">state</span>的实现可以使用这个提示的预取相关数据，因此，//如果这可以提高哈希加密计算方法的性能（当被调用在以后的时间）</span><br><span class="line">	PerfHintKeyChanged(chaincodeID string, key string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="state_delta_iterator">state_delta_iterator</h1><p>state增量迭代器结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDeltaIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	updates         <span class="keyword">map</span>[<span class="typename">string</span>]*UpdatedValue <span class="comment">//更新</span></span><br><span class="line">	relevantKeys    []<span class="typename">string</span>   <span class="comment">// 关联键</span></span><br><span class="line">	currentKeyIndex <span class="typename">int</span>  <span class="comment">// 当前键的索引</span></span><br><span class="line">	done            <span class="typename">bool</span> <span class="comment">//完成标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="state_delta">state_delta</h1><p>控制变现有的状态。这个结构被用于TX-batchAlso的执行期间中保持未提交的变化，以用于以块的状态转移到另一peer<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">StateDelta</span> struct <span class="container">&#123;</span><br><span class="line">	<span class="type">ChaincodeStateDeltas</span> map[string]*<span class="type">ChaincodeStateDelta</span></span><br><span class="line">	//允许一个控制此增量是否会向前或向后回滚的状态</span><br><span class="line">	<span class="type">RollBackwards</span> bool</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="IsUpdatedValueSet">IsUpdatedValueSet</h2><p>如果更新值已经设置为给定的chaincode ID和密钥，则为true<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stateDelta *StateDelta)</span> <span class="title">IsUpdatedValueSet</span><span class="params">(chaincodeID, key string)</span> <span class="title">bool</span> &#123;</span></span><br><span class="line">	chaincodeStateDelta, ok := stateDelta.ChaincodeStateDeltas[chaincodeID]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := chaincodeStateDelta.UpdatedKVs[key]<span class="comment">; ok &#123;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ApplyChanges">ApplyChanges</h2><p>合并另一增量- 如果一个键值存在，则现有键的值被覆盖<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Delta *StateDelta) ApplyChanges(anotherStateDelta *StateDelta) &#123;</span><br><span class="line">	<span class="keyword">for</span> chaincodeID, chaincodeStateDelta := range anotherStateDelta.ChaincodeStateDeltas &#123;</span><br><span class="line">		existingChaincodeStateDelta, existingChaincode := <span class="keyword">state</span>Delta.ChaincodeStateDeltas[chaincodeID]</span><br><span class="line">		<span class="keyword">for</span> key, valueHolder := range chaincodeStateDelta.UpdatedKVs &#123;</span><br><span class="line">			var previousValue []byte</span><br><span class="line">			if existingChaincode &#123;</span><br><span class="line">				existingUpdateValue, existingUpdate := existingChaincodeStateDelta.UpdatedKVs[key]</span><br><span class="line">				if existingUpdate &#123;</span><br><span class="line">					// 现有的状态增量已经为这个键值的更新值</span><br><span class="line">					previousValue = existingUpdateValue.PreviousValue</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					//使用以前的值在新的状态增量的设置</span><br><span class="line">					previousValue = valueHolder.PreviousValue</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				//使用之前值的状态增量</span><br><span class="line">				previousValue = valueHolder.PreviousValue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if valueHolder.IsDelete() &#123;</span><br><span class="line">				<span class="keyword">state</span>Delta.Delete(chaincodeID, key, previousValue)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				<span class="keyword">state</span>Delta.Set(chaincodeID, key, valueHolder.Value, previousValue)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GetUpdatedChaincodeIds">GetUpdatedChaincodeIds</h2><p>返回在存在于chaincodeIDs的状态增量<br>如果排序为true，方法按照字典顺序返回在排序之前的chaincodeIDs的排序顺序<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">state</span>Delta *StateDelta) GetUpdatedChaincodeIds(sorted bool) []string &#123;</span><br><span class="line">	updatedChaincodeIds := make([]string, len(<span class="keyword">state</span>Delta.ChaincodeStateDeltas))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := range <span class="keyword">state</span>Delta.ChaincodeStateDeltas &#123;</span><br><span class="line">		updatedChaincodeIds[i] = k</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	if sorted &#123;</span><br><span class="line">		sort.Strings(updatedChaincodeIds)</span><br><span class="line">	&#125;</span><br><span class="line">	return updatedChaincodeIds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>好了，ledger源码就分析到这里，其实仔细观察，会发现只要有一个iterrator，就会重写对应的next、getvalue方法等，各个模块之间相互协作，比较难的就是hash加密算法，以及状态增量的计算。小编接下来将对各个模块之间进行结构功能图解，敬请期待</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/BlockChain/">BlockChain</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	<div class="share-jiathis">
	  
<div class="jiathis_style_24x24">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_googleplus"></a>
	<a class="jiathis_button_douban"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
" charset="utf-8"></script>      

	 </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/04/04/IBM-openblockchain学习-四-crypto源码分析/" title="IBM openblockchain学习(四)--crypto源码分析">
  <strong>上一篇：</strong><br/>
  <span>
  IBM openblockchain学习(四)--crypto源码分析</span>
</a>
</div>


<div class="next">
<a href="/2016/03/24/IBM-openblockchain学习-二-chaincode源码分析/"  title="IBM openblockchain学习(二)--chaincode源码分析">
 <strong>下一篇：</strong><br/> 
 <span>IBM openblockchain学习(二)--chaincode源码分析
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/04/02/IBM-openblockchain学习-三-Ledger源码分析/" data-title="IBM openblockchain学习(三)--Ledger源码分析" data-url="http://pangjiuzala.github.io/2016/04/02/IBM-openblockchain学习-三-Ledger源码分析/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain"><span class="toc-number">1.</span> <span class="toc-text">blockchain</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newBlockchain"><span class="toc-number">1.1.</span> <span class="toc-text">newBlockchain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#startIndexer()"><span class="toc-number">1.2.</span> <span class="toc-text">startIndexer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getLastBlock"><span class="toc-number">1.3.</span> <span class="toc-text">getLastBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getSize"><span class="toc-number">1.4.</span> <span class="toc-text">getSize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlock"><span class="toc-number">1.5.</span> <span class="toc-text">getBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlockByHash"><span class="toc-number">1.6.</span> <span class="toc-text">getBlockByHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionByUUID"><span class="toc-number">1.7.</span> <span class="toc-text">getTransactionByUUID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactions"><span class="toc-number">1.8.</span> <span class="toc-text">getTransactions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionsByBlockHash"><span class="toc-number">1.9.</span> <span class="toc-text">getTransactionsByBlockHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransaction"><span class="toc-number">1.10.</span> <span class="toc-text">getTransaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTransactionByBlockHash"><span class="toc-number">1.11.</span> <span class="toc-text">getTransactionByBlockHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBlockchainInfo"><span class="toc-number">1.12.</span> <span class="toc-text">getBlockchainInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buildBlock"><span class="toc-number">1.13.</span> <span class="toc-text">buildBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addPersistenceChangesForNewBlock"><span class="toc-number">1.14.</span> <span class="toc-text">addPersistenceChangesForNewBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blockPersistenceStatus"><span class="toc-number">1.15.</span> <span class="toc-text">blockPersistenceStatus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#persistRawBlock"><span class="toc-number">1.16.</span> <span class="toc-text">persistRawBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockFromDB"><span class="toc-number">1.17.</span> <span class="toc-text">fetchBlockFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchTransactionFromDB"><span class="toc-number">1.18.</span> <span class="toc-text">fetchTransactionFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockchainSizeFromDB"><span class="toc-number">1.19.</span> <span class="toc-text">fetchBlockchainSizeFromDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchBlockchainSizeFromSnapshot"><span class="toc-number">1.20.</span> <span class="toc-text">fetchBlockchainSizeFromSnapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.21.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain_indexes"><span class="toc-number">2.</span> <span class="toc-text">blockchain_indexes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#addIndexDataForPersistence"><span class="toc-number">2.1.</span> <span class="toc-text">addIndexDataForPersistence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getAuthorisedAddresses"><span class="toc-number">2.2.</span> <span class="toc-text">getAuthorisedAddresses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodeBlockNumber"><span class="toc-number">2.3.</span> <span class="toc-text">encodeBlockNumber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodeBlockNumTxIndex"><span class="toc-number">2.4.</span> <span class="toc-text">encodeBlockNumTxIndex</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#blockchain_indexes_async"><span class="toc-number">3.</span> <span class="toc-text">blockchain_indexes_async</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#createIndexesInternal"><span class="toc-number">3.1.</span> <span class="toc-text">createIndexesInternal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#indexPendingBlocks"><span class="toc-number">3.2.</span> <span class="toc-text">indexPendingBlocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blockIndexed"><span class="toc-number">3.3.</span> <span class="toc-text">blockIndexed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitForLastCommittedBlock"><span class="toc-number">3.4.</span> <span class="toc-text">waitForLastCommittedBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetchLastIndexedBlockNumFromDB"><span class="toc-number">3.5.</span> <span class="toc-text">fetchLastIndexedBlockNumFromDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ledger"><span class="toc-number">4.</span> <span class="toc-text">ledger</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GetLedger"><span class="toc-number">4.1.</span> <span class="toc-text">GetLedger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeginTxBatch"><span class="toc-number">4.2.</span> <span class="toc-text">BeginTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTXBatchPreviewBlock"><span class="toc-number">4.3.</span> <span class="toc-text">GetTXBatchPreviewBlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitTxBatch"><span class="toc-number">4.4.</span> <span class="toc-text">CommitTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RollbackTxBatch"><span class="toc-number">4.5.</span> <span class="toc-text">RollbackTxBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TxBegin"><span class="toc-number">4.6.</span> <span class="toc-text">TxBegin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TxFinished"><span class="toc-number">4.7.</span> <span class="toc-text">TxFinished</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTempStateHash"><span class="toc-number">4.8.</span> <span class="toc-text">GetTempStateHash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetTempStateHashWithTxDeltaStateHashes"><span class="toc-number">4.9.</span> <span class="toc-text">GetTempStateHashWithTxDeltaStateHashes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetState"><span class="toc-number">4.10.</span> <span class="toc-text">GetState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateRangeScanIterator"><span class="toc-number">4.11.</span> <span class="toc-text">GetStateRangeScanIterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateSnapshot"><span class="toc-number">4.12.</span> <span class="toc-text">GetStateSnapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetStateDelta"><span class="toc-number">4.13.</span> <span class="toc-text">GetStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyStateDelta"><span class="toc-number">4.14.</span> <span class="toc-text">ApplyStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitStateDelta"><span class="toc-number">4.15.</span> <span class="toc-text">CommitStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RollbackStateDelta"><span class="toc-number">4.16.</span> <span class="toc-text">RollbackStateDelta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VerifyChain"><span class="toc-number">4.17.</span> <span class="toc-text">VerifyChain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sendProducerBlockEvent"><span class="toc-number">4.18.</span> <span class="toc-text">sendProducerBlockEvent</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#genesis"><span class="toc-number">5.</span> <span class="toc-text">genesis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MakeGenesis"><span class="toc-number">5.1.</span> <span class="toc-text">MakeGenesis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BuildLocal"><span class="toc-number">5.2.</span> <span class="toc-text">BuildLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DeployLocal"><span class="toc-number">5.3.</span> <span class="toc-text">DeployLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deployUpdateValidityPeriodChaincode"><span class="toc-number">5.4.</span> <span class="toc-text">deployUpdateValidityPeriodChaincode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#util"><span class="toc-number">6.</span> <span class="toc-text">util</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EncodeOrderPreservingVarUint64"><span class="toc-number">6.1.</span> <span class="toc-text">EncodeOrderPreservingVarUint64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DecodeOrderPreservingVarUint64"><span class="toc-number">6.2.</span> <span class="toc-text">DecodeOrderPreservingVarUint64</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buckettree"><span class="toc-number">7.</span> <span class="toc-text">buckettree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_hash"><span class="toc-number">7.1.</span> <span class="toc-text">bucket_hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addNextNode"><span class="toc-number">7.1.1.</span> <span class="toc-text">addNextNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeCryptoHash"><span class="toc-number">7.1.2.</span> <span class="toc-text">computeCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendCurrentChaincodeData"><span class="toc-number">7.1.3.</span> <span class="toc-text">appendCurrentChaincodeData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendSizeAndData"><span class="toc-number">7.1.4.</span> <span class="toc-text">appendSizeAndData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendSize"><span class="toc-number">7.1.5.</span> <span class="toc-text">appendSize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_key"><span class="toc-number">7.2.</span> <span class="toc-text">bucket_key</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newBucketKey"><span class="toc-number">7.2.1.</span> <span class="toc-text">newBucketKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getChildIndex"><span class="toc-number">7.2.2.</span> <span class="toc-text">getChildIndex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_node"><span class="toc-number">7.3.</span> <span class="toc-text">bucket_node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unmarshalBucketNode"><span class="toc-number">7.3.1.</span> <span class="toc-text">unmarshalBucketNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mergeBucketNode"><span class="toc-number">7.3.2.</span> <span class="toc-text">mergeBucketNode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket_tree_delta"><span class="toc-number">7.4.</span> <span class="toc-text">bucket_tree_delta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#config"><span class="toc-number">7.5.</span> <span class="toc-text">config</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datakey"><span class="toc-number">7.6.</span> <span class="toc-text">Datakey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data_nodes_delta"><span class="toc-number">7.7.</span> <span class="toc-text">data_nodes_delta</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newDataNodesDelta"><span class="toc-number">7.7.1.</span> <span class="toc-text">newDataNodesDelta</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getAffectedBuckets"><span class="toc-number">7.7.2.</span> <span class="toc-text">getAffectedBuckets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range_scan_iterator"><span class="toc-number">7.8.</span> <span class="toc-text">range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snapshot_iterator"><span class="toc-number">7.9.</span> <span class="toc-text">snapshot_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_impl"><span class="toc-number">7.10.</span> <span class="toc-text">state_impl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewStateImpl"><span class="toc-number">7.10.1.</span> <span class="toc-text">NewStateImpl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialize"><span class="toc-number">7.10.2.</span> <span class="toc-text">Initialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrepareWorkingSet"><span class="toc-number">7.10.3.</span> <span class="toc-text">PrepareWorkingSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeDataNodesCryptoHash"><span class="toc-number">7.10.4.</span> <span class="toc-text">computeDataNodesCryptoHash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state"><span class="toc-number">8.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#composite_range_scan_iterator"><span class="toc-number">8.1.</span> <span class="toc-text">composite_range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_snapshot"><span class="toc-number">8.2.</span> <span class="toc-text">state_snapshot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state-1"><span class="toc-number">8.3.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewState"><span class="toc-number">8.3.1.</span> <span class="toc-text">NewState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TxBegin-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">TxBegin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get"><span class="toc-number">8.3.3.</span> <span class="toc-text">Get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetRangeScanIterator"><span class="toc-number">8.3.4.</span> <span class="toc-text">GetRangeScanIterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetHash"><span class="toc-number">8.3.5.</span> <span class="toc-text">GetHash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#trie"><span class="toc-number">9.</span> <span class="toc-text">trie</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TrieKey"><span class="toc-number">9.1.</span> <span class="toc-text">TrieKey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieKey"><span class="toc-number">9.1.1.</span> <span class="toc-text">newTrieKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieKeyFromCompositeKey"><span class="toc-number">9.1.2.</span> <span class="toc-text">newTrieKeyFromCompositeKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getIndexInParent"><span class="toc-number">9.1.3.</span> <span class="toc-text">getIndexInParent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getParentTrieKey"><span class="toc-number">9.1.4.</span> <span class="toc-text">getParentTrieKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getEncodedBytes"><span class="toc-number">9.1.5.</span> <span class="toc-text">getEncodedBytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assertIsChildOf"><span class="toc-number">9.1.6.</span> <span class="toc-text">assertIsChildOf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trie_node"><span class="toc-number">9.2.</span> <span class="toc-text">trie_node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setChildCryptoHash"><span class="toc-number">9.2.1.</span> <span class="toc-text">setChildCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mergeMissingAttributesFrom"><span class="toc-number">9.2.2.</span> <span class="toc-text">mergeMissingAttributesFrom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeCryptoHash-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">computeCryptoHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#marshal"><span class="toc-number">9.2.4.</span> <span class="toc-text">marshal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSortedChildrenIndex"><span class="toc-number">9.2.5.</span> <span class="toc-text">getSortedChildrenIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newTrieDelta"><span class="toc-number">9.2.6.</span> <span class="toc-text">newTrieDelta</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trie_db_helper"><span class="toc-number">9.3.</span> <span class="toc-text">trie_db_helper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#byteTrieKey"><span class="toc-number">9.4.</span> <span class="toc-text">byteTrieKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hexTrieKey"><span class="toc-number">9.5.</span> <span class="toc-text">hexTrieKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range_scan_iterator-1"><span class="toc-number">9.6.</span> <span class="toc-text">range_scan_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#snapshot_iterator-1"><span class="toc-number">9.7.</span> <span class="toc-text">snapshot_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state_trie"><span class="toc-number">9.8.</span> <span class="toc-text">state_trie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#processChangedNode"><span class="toc-number">9.8.1.</span> <span class="toc-text">processChangedNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AddChangesForPersistence"><span class="toc-number">9.8.2.</span> <span class="toc-text">AddChangesForPersistence</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commons"><span class="toc-number">10.</span> <span class="toc-text">commons</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashable_state"><span class="toc-number">10.1.</span> <span class="toc-text">hashable_state</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state_delta_iterator"><span class="toc-number">11.</span> <span class="toc-text">state_delta_iterator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state_delta"><span class="toc-number">12.</span> <span class="toc-text">state_delta</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IsUpdatedValueSet"><span class="toc-number">12.1.</span> <span class="toc-text">IsUpdatedValueSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyChanges"><span class="toc-number">12.2.</span> <span class="toc-text">ApplyChanges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetUpdatedChaincodeIds"><span class="toc-number">12.3.</span> <span class="toc-text">GetUpdatedChaincodeIds</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2129798793&verifier=c0951e84&dpc=1"></iframe>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>31</sup></a></li>
			
		
			
				<li><a href="/tags/大数据/" title="大数据">大数据<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/性能优化/" title="性能优化">性能优化<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/HBase/" title="HBase">HBase<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Spark/" title="Spark">Spark<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/BlockChain/" title="BlockChain">BlockChain<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/数据库/" title="数据库">数据库<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/移动互联网/" title="移动互联网">移动互联网<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/网络爬虫/" title="网络爬虫">网络爬虫<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/物联网/" title="物联网">物联网<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/云平台/" title="云平台">云平台<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/智慧医疗/" title="智慧医疗">智慧医疗<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">25</span></li></ul>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.csdn.net/pangjiuzala" target="_blank" title="My Blog in  CSDN">CSDN</a>
            
          </li>
        
          <li>
            
            	<a href="http://saliormoon.github.io/" target="_blank" title="王宇峰的博客">王宇峰的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.changhuiyuan.com/" target="_blank" title="常惠源的博客">常惠源的博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="https://github.com/search?q=pangjiuzala&amp;type=Users" target="_blank" title="关注刘兴的github">关注</a>
</div>

  

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello,I&#39;m from ZjuCs! <br/>
			The more you diligent, the more you lucky!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright@ 2015 Liuxing All rights reserved.
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"pangjiuzala"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffeafc504b70a541dd3845d467335f367' type='text/javascript'%3E%3C/script%3E"));
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_null'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3Dnull' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<script>
var option = {
  engineKey: '4ac092ad8d749fdc6293'
};
(function(w,d,t,u,n,s,e){
  s = d.createElement(t);
  s.src = u;
  s.async = 1;
  w[n] = function(r){
    w[n].opts = r;
  };
  e = d.getElementsByTagName(t)[0];
  e.parentNode.insertBefore(s, e);
})(window,document,'script','//tinysou-cdn.b0.upaiyun.com/ts.js','_ts');
_ts(option);
</script>

<!-- Tiny_search End -->

  </body>
</html>
